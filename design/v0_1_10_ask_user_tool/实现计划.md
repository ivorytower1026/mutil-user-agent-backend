# v0.1.9 实现计划

## 一、后端修改

### 1. `src/agent_manager.py`

#### 1.1 添加辅助方法

在 `_make_sse` 方法附近添加：

```python
def _format_interrupt_info(self, request: dict) -> str:
    """生成用户友好的中断描述"""
    tool_name = request.get("name", "Unknown")
    args = request.get("args", {})
    
    if tool_name == "execute":
        command = args.get("command", "")
        cmd_preview = command[:30] + "..." if len(command) > 30 else command
        return f"正在执行命令: {cmd_preview}"
    elif tool_name == "write_file":
        file_path = args.get("file_path", "")
        file_name = os.path.basename(file_path) if file_path else "文件"
        return f"正在写入文件: {file_name}"
    elif tool_name == "ask_user":
        questions = args.get("questions", [])
        return f"Agent 提出了 {len(questions)} 个问题"
    else:
        return f"正在执行操作"

def _get_task_display_name(self, tool_name: str) -> str:
    """将工具名转换为中文显示名"""
    name_map = {
        "execute": "执行命令",
        "write_file": "写入文件",
        "ask_user": "用户问答",
    }
    return name_map.get(tool_name, tool_name)
```

#### 1.2 新增 `ask_user` 工具

```python
from langchain_core.tools import StructuredTool
from typing import Annotated

def _create_ask_user_tool(self) -> BaseTool:
    def ask_user(
        questions: Annotated[list[dict], "问题列表，每个问题包含 question 和 options"],
        answers: Annotated[list[str] | None, "用户答案（恢复时注入）"] = None,
    ) -> str:
        """
        questions 格式:
        [
            {
                "question": "你喜欢什么颜色?",
                "options": [
                    {"label": "红色", "value": "red"},
                    {"label": "绿色", "value": "green"},
                    {"label": "自定义", "value": "__custom__", "allow_custom": true}
                ]
            }
        ]
        """
        if answers:
            return json.dumps(answers, ensure_ascii=False)
        return "Waiting for user response..."
    
    return StructuredTool.from_function(
        name="ask_user",
        description="向用户提问并等待回答。问题格式: [{question: string, options: [{label: string, value: string, allow_custom?: boolean}]}]",
        func=ask_user,
    )
```

#### 1.3 修改 `init()` 方法

```python
async def init(self):
    await self.pool.open()
    self.checkpointer = AsyncPostgresSaver(self.pool)
    await self.checkpointer.setup()

    self.compiled_agent = create_deep_agent(
        model=big_llm,
        backend=lambda runtime: get_thread_backend(
            self._get_thread_id(runtime) or "default"
        ),
        checkpointer=self.checkpointer,
        tools=[self._create_ask_user_tool()],  # 新增
        interrupt_on={
            "execute": True, 
            "write_file": True,
            "ask_user": {  # 新增
                "allowed_decisions": ["edit"],
                "description": "Agent 请求用户回答问题"
            }
        },
        system_prompt="用户的工作目录在/workspace中，若无明确要求，请在/workspace目录【及子目录】下执行操作",
    )
    print("[AgentManager] Initialized with AsyncPostgresSaver")
```

#### 1.4 修改 `_format_stream_data` 方法

```python
# 第 154-165 行
if "__interrupt__" in data:
    interrupt_list = data["__interrupt__"]
    if interrupt_list:
        interrupt = interrupt_list[0]
        requests = interrupt.value.get("action_requests", [])
        if requests:
            request = requests[0]
            return self._make_sse("interrupt", {
                "info": self._format_interrupt_info(request),
                "taskName": self._get_task_display_name(request.get("name", "Unknown")),
                "data": self._sanitize_for_json(interrupt.value),
                "questions": request.get("args", {}).get("questions"),  # 新增
            })
```

#### 1.5 修改 `stream_resume_interrupt` 方法

```python
async def stream_resume_interrupt(
    self, 
    thread_id: str, 
    action: str,
    answers: list[str] | None = None
) -> AsyncIterator[str]:
    if action not in ["continue", "cancel", "answer"]:
        raise ValueError("Action must be 'continue', 'cancel' or 'answer'")

    handler, _ = init_langfuse()
    config: RunnableConfig = {"configurable": {"thread_id": thread_id}, "callbacks": [handler]}

    if action == "cancel":
        resume_command = Command(resume={"decisions": [{"type": "reject"}]})
    elif action == "answer" and answers:
        snapshot = await self.compiled_agent.aget_state(config)
        original_args = self._extract_interrupt_args(snapshot, "ask_user")
        
        resume_command = Command(resume={
            "decisions": [{
                "type": "edit",
                "edited_action": {
                    "name": "ask_user",
                    "args": {**original_args, "answers": answers}
                }
            }]
        })
    else:  # continue
        resume_command = Command(resume={"decisions": [{"type": "approve"}]})

    print(f"[DEBUG] stream_resume_interrupt: thread_id={thread_id}, action={action}")

    try:
        async for chunk in self.compiled_agent.astream(
            resume_command,
            config=config,
            stream_mode=["messages", "updates"],
            subgraphs=True,
        ):
            formatted = self._format_astream_chunk(chunk)
            if formatted:
                yield formatted
    except Exception as e:
        import traceback
        error_msg = f"{type(e).__name__}: {str(e)}"
        print(f"[ERROR] In stream_resume_interrupt: {error_msg}")
        traceback.print_exc()
        yield self._make_sse("error", {"message": error_msg})
        return
    finally:
        yield self._make_sse("done", {"action": action})

def _extract_interrupt_args(self, snapshot: Any, tool_name: str) -> dict:
    """从 snapshot 中提取指定工具的参数"""
    if snapshot.tasks:
        for task in snapshot.tasks:
            if hasattr(task, "interrupts") and task.interrupts:
                for interrupt in task.interrupts:
                    if hasattr(interrupt, "value"):
                        requests = interrupt.value.get("action_requests", [])
                        for req in requests:
                            if req.get("name") == tool_name:
                                return req.get("args", {})
    return {}
```

---

### 2. `api/models.py`

```python
class ResumeRequest(BaseModel):
    action: str  # "continue" | "cancel" | "answer"
    answers: list[str] | None = None
```

---

### 3. `api/server.py`

```python
@router.post("/resume/{thread_id}")
async def stream_resume_interrupt(
    thread_id: str,
    request: ResumeRequest,
    user_id: str = Depends(get_current_user)
):
    """Resume an interrupted session (HITL) with streaming."""
    verify_thread_permission(user_id, thread_id)

    if request.action not in ["continue", "cancel", "answer"]:
        raise HTTPException(
            status_code=400,
            detail="Action must be 'continue', 'cancel' or 'answer'"
        )
    
    if request.action == "answer" and not request.answers:
        raise HTTPException(
            status_code=400,
            detail="answers is required when action is 'answer'"
        )

    async def event_generator() -> AsyncGenerator[str, None]:
        async for chunk in agent_manager.stream_resume_interrupt(
            thread_id, request.action, request.answers
        ):
            yield chunk

    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream"
    )
```

---

## 二、前端修改

### 1. `src/types/chat.ts`

```typescript
export interface QuestionOption {
  label: string
  value: string
  allow_custom?: boolean
}

export interface Question {
  question: string
  options: QuestionOption[]
}

export interface InterruptOption {
  id: string
  label: string
  description?: string
  icon?: string
}

export interface Interrupt {
  taskName: string
  info: string
  data?: Record<string, unknown>
  options?: InterruptOption[]
  questions?: Question[]  // 新增
}
```

---

### 2. `src/types/api.ts`

```typescript
export interface ResumeRequest {
  action: string  // "continue" | "cancel" | "answer"
  answers?: string[]
}
```

---

### 3. `src/components/interrupt/InterruptDetail.vue`

```vue
<template>
  <div class="interrupt-detail">
    <!-- 普通中断选项（execute, write_file） -->
    <template v-if="!interrupt.questions?.length">
      <div class="interrupt-header">
        <div class="interrupt-info">{{ interrupt.info }}</div>
        <v-chip
          v-if="interrupt.taskName"
          size="small"
          color="primary"
          variant="flat"
        >
          {{ interrupt.taskName }}
        </v-chip>
      </div>
      
      <div class="options-list">
        <div
          v-for="option in displayOptions"
          :key="option.id"
          class="option-card"
          :class="{ selected: modelValue === option.id }"
          @click="$emit('update:modelValue', option.id)"
        >
          <v-icon v-if="option.icon" size="18" class="option-icon">
            {{ option.icon }}
          </v-icon>
          <div class="option-content">
            <div class="option-label">{{ option.label }}</div>
            <div v-if="option.description" class="option-desc">
              {{ option.description }}
            </div>
          </div>
          <v-icon v-if="modelValue === option.id" size="18" color="primary" class="check-icon">
            mdi-check-circle
          </v-icon>
        </div>
      </div>
    </template>
    
    <!-- 问答表单（ask_user） -->
    <template v-else>
      <div class="questions-list">
        <div 
          v-for="(q, qIdx) in interrupt.questions" 
          :key="qIdx" 
          class="question-item"
        >
          <div class="question-text">{{ qIdx + 1 }}. {{ q.question }}</div>
          <div class="question-options">
            <div
              v-for="opt in q.options"
              :key="opt.value"
              class="option-card compact"
              :class="{ selected: isOptionSelected(qIdx, opt) }"
              @click="selectOption(qIdx, opt)"
            >
              <span class="option-label">{{ opt.label }}</span>
            </div>
          </div>
          <!-- 自定义输入框 -->
          <v-text-field
            v-if="hasCustomInput(qIdx)"
            v-model="customInputs[qIdx]"
            density="compact"
            variant="outlined"
            placeholder="请输入您的回答..."
            hide-details
            class="custom-input"
            @update:modelValue="updateCustomAnswer(qIdx)"
          />
        </div>
      </div>
    </template>
  </div>
</template>

<script setup lang="ts">
import { ref, watch, computed } from 'vue'
import type { Interrupt, InterruptOption, Question, QuestionOption } from '@/types/chat'

const props = defineProps<{
  interrupt: Interrupt
  modelValue?: string
}>()

const emit = defineEmits<{
  'update:modelValue': [value: string]
  'update:answers': [value: string[]]
}>()

// 普通 option 的默认选项
const defaultOptions: InterruptOption[] = [
  { id: 'continue', label: '继续执行', description: '按原计划继续执行任务', icon: 'mdi-play' },
  { id: 'cancel', label: '取消执行', description: '终止当前任务并返回', icon: 'mdi-stop' }
]

const displayOptions = computed(() => {
  return props.interrupt.options?.length ? props.interrupt.options : defaultOptions
})

// 问答相关
const localAnswers = ref<string[]>([])
const customInputs = ref<Record<number, string>>({})

watch(() => props.interrupt.questions, (questions) => {
  if (questions?.length) {
    localAnswers.value = new Array(questions.length).fill('')
    customInputs.value = {}
  }
}, { immediate: true })

// 监听答案变化，实时同步
watch(localAnswers, () => {
  emit('update:answers', [...localAnswers.value])
}, { deep: true })

function isOptionSelected(qIdx: number, opt: QuestionOption): boolean {
  const current = localAnswers.value[qIdx]
  if (opt.allow_custom) {
    // 自定义选项：选中当前不是任何固定选项值的情况
    const fixedValues = props.interrupt.questions![qIdx].options
      .filter(o => !o.allow_custom)
      .map(o => o.value)
    return !fixedValues.includes(current) && !!current
  }
  return current === opt.value
}

function selectOption(qIdx: number, opt: QuestionOption) {
  if (opt.allow_custom) {
    // 选中自定义选项时，清空之前的输入
    customInputs.value[qIdx] = ''
    localAnswers.value[qIdx] = '__custom__'
  } else {
    localAnswers.value[qIdx] = opt.value
  }
}

function hasCustomInput(qIdx: number): boolean {
  const q = props.interrupt.questions?.[qIdx]
  if (!q) return false
  const currentAnswer = localAnswers.value[qIdx]
  // 只有当自定义选项被选中时才显示输入框
  const customOpt = q.options.find(o => o.allow_custom)
  return customOpt && currentAnswer === '__custom__'
}

function updateCustomAnswer(qIdx: number) {
  localAnswers.value[qIdx] = customInputs.value[qIdx] || ''
}
</script>

<style scoped>
/* 原有样式保持不变 */

.questions-list {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.question-item {
  padding: 12px;
  background-color: rgba(0, 0, 0, 0.02);
  border-radius: 8px;
}

.question-text {
  font-weight: 500;
  font-size: 14px;
  margin-bottom: 8px;
  color: rgba(0, 0, 0, 0.87);
}

.question-options {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.option-card.compact {
  padding: 8px 12px;
}

.custom-input {
  margin-top: 8px;
}

.v-theme--dark .question-item {
  background-color: rgba(255, 255, 255, 0.04);
}

.v-theme--dark .question-text {
  color: rgba(255, 255, 255, 0.95);
}
</style>
```

---

### 4. `src/components/chat/ChatInput.vue`

```vue
<script setup lang="ts">
import { ref, watch, computed } from 'vue'
import type { Interrupt } from '@/types/chat'
import InterruptDetail from '@/components/interrupt/InterruptDetail.vue'
import type { PendingFile } from '@/composables/useChatStream'

const props = withDefaults(defineProps<{
  disabled?: boolean
  placeholder?: string
  isLoading?: boolean
  interrupt?: Interrupt | null
  pendingFiles?: PendingFile[]
}>(), {
  disabled: false,
  placeholder: '给 AI 发送消息',
  isLoading: false,
  interrupt: null,
  pendingFiles: () => []
})

const emit = defineEmits<{
  send: [message: string]
  resume: [action: string, answers?: string[]]
  addFiles: [files: File[]]
  removeFile: [index: number]
}>()

const selectedOptionId = ref<string>('')
const selectedAnswers = ref<string[]>([])

// 监听 interrupt 变化
watch(() => props.interrupt, (newInterrupt) => {
  if (newInterrupt?.questions?.length) {
    selectedAnswers.value = new Array(newInterrupt.questions.length).fill('')
  } else if (newInterrupt?.options?.length) {
    selectedOptionId.value = newInterrupt.options[0].id
  } else {
    selectedOptionId.value = 'continue'
  }
}, { immediate: true })

// 是否可以确认
const canConfirm = computed(() => {
  if (props.interrupt?.questions?.length) {
    // 问答类型：所有问题都必须回答
    return selectedAnswers.value.every(a => a && a.trim() !== '')
  }
  // 普通中断：必须选中一个选项
  return !!selectedOptionId.value
})

function handleConfirm() {
  if (props.interrupt?.questions?.length) {
    if (canConfirm.value) {
      emit('resume', 'answer', [...selectedAnswers.value])
    }
  } else {
    emit('resume', selectedOptionId.value)
  }
}

// ... 其他方法保持不变
</script>

<template>
  <div class="chat-input-wrapper">
    <div v-if="isLoading && !interrupt" class="status-bar">
      <v-progress-circular indeterminate size="16" width="2" />
      <span>AI 正在思考中...</span>
    </div>
    
    <div v-if="interrupt" class="interrupt-selector">
      <div class="interrupt-header">
        <v-icon color="warning" size="20">
          {{ interrupt.questions?.length ? 'mdi-help-circle-outline' : 'mdi-alert-circle-outline' }}
        </v-icon>
        <span class="interrupt-title">
          {{ interrupt.questions?.length ? '请回答以下问题' : '需要人工确认' }}
        </span>
      </div>
      
      <InterruptDetail
        :interrupt="interrupt"
        v-model="selectedOptionId"
        v-model:answers="selectedAnswers"
      />
      
      <div class="interrupt-actions">
        <v-btn
          color="primary"
          variant="flat"
          :loading="isLoading"
          :disabled="!canConfirm"
          @click="handleConfirm"
        >
          <v-icon start size="18">mdi-check</v-icon>
          确认选择
        </v-btn>
      </div>
    </div>
    
    <!-- ... 其他内容保持不变 ... -->
  </div>
</template>
```

---

### 5. `src/composables/useChatStream.ts`

```typescript
import type { SSEEvent, InterruptOption, Question } from '@/types'

// ... 其他代码 ...

async function resumeInterrupt(
  threadId: string, 
  action: string, 
  answers?: string[]
) {
  chatStore.setLoading(true)
  chatStore.clearInterrupt()
  
  abortController.value = new AbortController()

  try {
    for await (const event of streamResume(threadId, action, answers, abortController.value.signal)) {
      handleEvent(event)
    }
  } catch (e: unknown) {
    chatStore.setError(e instanceof Error ? e.message : 'Unknown error')
  } finally {
    chatStore.setLoading(false)
    abortController.value = null
  }
}

function handleEvent(event: SSEEvent) {
  switch (event.event) {
    // ... 其他 case ...

    case 'interrupt':
      {
        const data = event.data || {}
        const rawOptions = data.options as InterruptOption[] | undefined
        const rawQuestions = data.questions as Question[] | undefined
        
        chatStore.setInterrupt({
          taskName: (data.task_name as string) || 'Unknown',
          info: event.info || (data.info as string) || '',
          data: event.data,
          options: rawOptions?.map(opt => ({
            id: opt.id || String(opt),
            label: opt.label || String(opt),
            description: opt.description,
            icon: opt.icon
          })),
          questions: rawQuestions,
        })
        if (sessionStore.currentThreadId) {
          sessionStore.updateSessionStatus(sessionStore.currentThreadId, 'interrupted')
        }
      }
      break

    // ... 其他 case ...
  }
}

return {
  sendMessage,
  resumeInterrupt,  // 修改后的签名
  stopStream,
  pendingFiles,
  addFiles,
  removeFile,
  clearFiles
}
```

---

### 6. `src/api/sse.ts`

```typescript
export async function* streamResume(
  threadId: string,
  action: string,
  answers?: string[],
  signal?: AbortSignal
): AsyncGenerator<SSEEvent> {
  const token = getToken()
  
  const body: Record<string, unknown> = { action }
  if (answers) {
    body.answers = answers
  }
  
  const response = await fetch(`${BASE_URL}/api/resume/${threadId}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {})
    },
    body: JSON.stringify(body),
    signal
  })

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`)
  }

  // ... 其余代码不变 ...
}
```

---

## 三、实现顺序

建议按以下顺序实现：

1. **后端**: `api/models.py` - 添加 `answers` 字段
2. **后端**: `src/agent_manager.py` - 添加辅助方法和工具
3. **后端**: `api/server.py` - 修改 `/resume` 端点
4. **前端**: `src/types/chat.ts` - 添加类型定义
5. **前端**: `src/types/api.ts` - 修改 `ResumeRequest`
6. **前端**: `src/api/sse.ts` - 修改 `streamResume`
7. **前端**: `src/composables/useChatStream.ts` - 修改事件处理
8. **前端**: `src/components/interrupt/InterruptDetail.vue` - 添加问答表单
9. **前端**: `src/components/chat/ChatInput.vue` - 处理确认逻辑

---

## 四、注意事项

1. **答案顺序**: `answers` 数组的顺序必须与 `questions` 数组的顺序一一对应
2. **自定义选项**: 当用户选择自定义选项时，答案值应该是用户输入的内容，而不是 `__custom__`
3. **验证**: 前端需要验证所有问题都已回答后才能提交
4. **兼容性**: 普通中断（execute, write_file）的处理逻辑保持不变
