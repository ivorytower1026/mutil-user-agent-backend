# 迭代开发计划

> v0.1.9 Skill 验证与管理

---

## 一、整体规划

### 1.1 迭代目标

实现 Agent Skill 的完整生命周期管理：上传 → 验证 → 审批 → 入库

### 1.2 开发周期

**总计：约 4 天**

| 阶段 | 内容 | 预计时间 | 依赖 |
|------|------|----------|------|
| Phase 1 | 数据库模型 + 迁移 + 格式验证 | 0.5天 | 无 |
| Phase 2 | 第一层验证（单独验证） | 1天 | Phase 1 |
| Phase 3 | 第二层验证（并行回归） | 1天 | Phase 2 |
| Phase 4 | 增量镜像管理 | 0.5天 | Phase 3 |
| Phase 5 | Skill 管理器 + Admin API | 0.5天 | Phase 4 |
| Phase 6 | 集成测试 | 0.5天 | Phase 5 |

---

## 二、Phase 1：数据库模型 + 迁移

### 2.1 目标

- User 表新增 `is_admin` 字段
- 新建 Skill 表
- 新建 ImageVersion 表

### 2.2 文件变更

```
src/database.py  # 修改
```

### 2.3 具体任务

**Task 1-1**：修改 User 表
```python
class User(Base):
    # 新增字段
    is_admin = Column(Boolean, default=False)
```

**Task 1-2**：创建 Skill 表
```python
class Skill(Base):
    __tablename__ = "skills"
    # 完整字段定义见数据库设计.md
```

**Task 1-3**：创建 ImageVersion 表
```python
class ImageVersion(Base):
    __tablename__ = "image_versions"
    # 完整字段定义见数据库设计.md
```

**Task 1-4**：数据库迁移
```python
# 在 create_tables() 中自动创建
# 或手动执行 SQL 迁移脚本
```

**Task 1-5**：格式验证（复用 DeepAgents）
```python
from deepagents.middleware.skills import _parse_skill_metadata

def validate_skill_format(skill_path: str) -> tuple[bool, list[str], list[str]]:
    """复用 DeepAgents 的验证逻辑"""
    skill_md_path = os.path.join(skill_path, "SKILL.md")
    
    # 1. 检查 SKILL.md 存在
    if not os.path.exists(skill_md_path):
        return False, ["Missing SKILL.md"], []
    
    # 2. 读取并解析
    with open(skill_md_path, encoding='utf-8') as f:
        content = f.read()
    
    # 3. 复用 DeepAgents 的解析逻辑
    directory_name = os.path.basename(skill_path)
    metadata = _parse_skill_metadata(content, skill_md_path, directory_name)
    
    if metadata is None:
        return False, ["Invalid frontmatter format or missing name/description"], []
    
    return True, [], []
```

### 2.4 验收标准

- [ ] User 表包含 is_admin 字段
- [ ] Skill 表创建成功，包含所有字段
- [ ] ImageVersion 表创建成功
- [ ] 索引和约束正确创建
- [ ] 格式验证复用 DeepAgents 逻辑
- [ ] 缺少 SKILL.md 时返回错误

### 2.5 测试

```python
def test_database_models():
    # 测试 User
    user = User(user_id="admin", username="admin", is_admin=True)
    
    # 测试 Skill
    skill = Skill(skill_id="test", name="test-skill", status="pending")
    
    # 测试 ImageVersion
    version = ImageVersion(version="v1.0", is_current=True)

def test_format_validation():
    # 测试有效 skill
    passed, errors, warnings = validate_skill_format("valid-skill/")
    assert passed == True
    
    # 测试缺少 SKILL.md
    passed, errors, warnings = validate_skill_format("no-md-skill/")
    assert passed == False
    assert "SKILL.md" in errors[0]
```

---

## 三、Phase 2：第一层验证（复用现有代码）

### 3.1 目标

- 实现双 Agent 验证机制（复用 create_deep_agent）
- 实现 Agent 自主安装依赖 + 断网测试（扩展 DockerSandboxBackend）
- 实现盲测机制
- 采集执行监控指标
- 实现报告生成子 Agent

### 3.2 文件变更

```
src/skill_agent_validator.py  # 新增（核心）
src/skill_metrics.py          # 新增
src/docker_sandbox.py         # 修改（添加网络控制方法）
```

### 3.3 具体任务

**Task 2-1**：创建验证编排器
```python
from src.docker_sandbox import DockerSandboxBackend

class ValidationOrchestrator:
    def __init__(self):
        self.validation_lock = asyncio.Lock()
        self.metrics_collector = MetricsCollector()
        self.report_generator = ReportGeneratorAgent()
        self.image_backend = LocalFileImageBackend()
    
    async def validate_layer1(self, skill_id: str) -> Layer1Result:
        pass
```

**Task 2-2**：实现动态网络控制（扩展 DockerSandboxBackend）
```python
# 在 src/docker_sandbox.py 中添加方法
class DockerSandboxBackend:
    # 现有代码保持不变...
    
    def disconnect_network(self) -> bool:
        """断开容器网络"""
        if self._container:
            self.client.networks.get("bridge").disconnect(self._container)
            return True
        return False
```

**Task 2-3**：实现验证 Agent（使用 DeepAgents 子代理机制）
```python
from deepagents import create_deep_agent

# 验证 Agent 使用内置的 write_todo + task() 子代理
# 子代理串行执行任务，验证 Agent 自己评分
validation_agent = create_deep_agent(
    model=big_llm,
    backend=lambda _: docker_backend,
    system_prompt=VALIDATION_AGENT_PROMPT,  # 包含评分标准
    skills=[skill_under_test] + approved_skills,
)
# Agent 自动：
# 1. 使用 write_todo 生成 3 个任务
# 2. 使用 task() 委托给子代理串行执行
# 3. 自己评估每个任务的完成度（1-5 分）
# 4. 生成评估报告
```

**Task 2-4**：实现命令历史记录
```python
def get_command_history(backend) -> list[str]:
    """获取 bash 历史命令"""
    backend.execute("history -a 2>/dev/null")
    result = backend.execute("cat ~/.bash_history 2>/dev/null || echo ''")
    return result.output.strip().split("\n") if result.output.strip() else []

def extract_dependencies_from_commands(commands: list[str]) -> dict:
    """从命令中提取依赖信息"""
    # 分类: pip/apt/npm/downloaded/other
    pass
```

**Task 2-5**：实现监控采集
```python
class MetricsCollector:
    async def collect(self, container_id: str) -> ExecutionMetrics:
        # 采集 CPU/内存/IO/时间
        pass
```

**Task 2-6**：实现报告生成子 Agent
```python
class ReportGeneratorAgent:
    """验证报告生成子 Agent"""
    
    def __init__(self):
        self.agent = create_deep_agent(
            model=flash_llm,
            system_prompt="""你是 Skill 验证报告生成专家。
            根据验证结果数据，生成 Markdown 格式的验证报告。
            参考"验证报告模板.md"的格式。"""
        )
    
    async def generate(self, validation_data: dict) -> str:
        """生成 Markdown 验证报告"""
        pass
```

### 3.4 验收标准

- [ ] 验证 Agent 使用 write_todo 生成任务
- [ ] 验证 Agent 使用 task() 委托给子代理串行执行
- [ ] 验证 Agent 自己评分（5 级制）
- [ ] 断网阶段成功执行测试
- [ ] 命令历史正确记录依赖操作
- [ ] 监控指标正确采集
- [ ] 报告生成子 Agent 生成 Markdown 报告

### 3.5 测试

```python
def test_layer1_validation():
    result = await orchestrator.validate_layer1(skill_id)
    
    assert result.passed in [True, False]
    assert result.blind_test.trigger_accuracy >= 0
    assert result.execution_metrics.cpu_percent >= 0

def test_report_generation():
    report = await report_generator.generate(validation_data)
    assert report.startswith("# Skill 验证报告")
```

---

## 四、Phase 3：第二层验证（并行回归）

### 4.1 目标

- 实现并行回归测试
- 复用已安装依赖的容器/镜像
- 汇总回归结果

### 4.2 文件变更

```
src/skill_agent_validator.py  # 扩展
```

### 4.3 具体任务

**Task 3-1**：实现并行回归测试
```python
async def validate_layer2_parallel(
    container, 
    approved_skills: list[str]
) -> Layer2Result:
    """并行回归测试所有已入库 skill"""
    
    # 创建并行任务
    tasks = [
        test_single_skill_regression(container, skill)
        for skill in approved_skills
    ]
    
    # 并行执行
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    return aggregate_results(results)
```

**Task 3-2**：单个 skill 回归测试
```python
async def test_single_skill_regression(
    container, 
    skill_name: str
) -> RegressionResult:
    """测试单个 skill（使用同一容器）"""
    
    # 1. 读取 skill 的 SKILL.md
    skill_md = read_skill_md(skill_name)
    
    # 2. 生成测试任务
    tasks = await validation_agent.generate_tasks(skill_md)
    
    # 3. 执行测试
    results = []
    for task in tasks:
        result = await execution_agent.execute_task(container, task)
        results.append(result)
    
    return RegressionResult(
        skill_name=skill_name,
        passed=all(r.completed for r in results),
        score=calculate_score(results)
    )
```

**Task 3-3**：结果汇总
```python
def aggregate_results(results: list) -> Layer2Result:
    """汇总所有回归结果"""
    
    passed = all(
        r.passed if not isinstance(r, Exception) else False 
        for r in results
    )
    
    failed_skills = [
        skill for skill, r in zip(skills, results)
        if isinstance(r, Exception) or not r.passed
    ]
    
    return Layer2Result(
        passed=passed,
        regression_results=...,
        failed_skills=failed_skills
    )
```

### 4.4 验收标准

- [ ] 回归测试并行执行
- [ ] 每个 skill 独立测试
- [ ] 正确汇总所有结果
- [ ] 记录失败的 skill

### 4.5 测试

```python
def test_layer2_parallel():
    # 模拟 3 个已入库 skill
    result = await orchestrator.validate_layer2(container, ["a", "b", "c"])
    
    assert result.total_skills_tested == 3
    assert isinstance(result.regression_results, dict)
```

---

## 五、Phase 4：增量镜像管理

### 5.1 目标

- 实现镜像版本管理（本地 tar 文件存储）
- 实现 ImageBackend 接口（预留私有仓库扩展）
- 实现 docker save/load
- 实现清理旧版本
- 实现回滚机制

### 5.2 文件变更

```
src/skill_image_manager.py  # 新增
src/config.py               # 修改（添加 SKILL_IMAGES_DIR）
```

### 5.3 具体任务

**Task 4-1**：定义 ImageBackend 接口
```python
from typing import Protocol

class ImageBackend(Protocol):
    """镜像存储后端接口"""
    def save(self, container_id: str, version: str) -> str: ...
    def load(self, version: str) -> str: ...
    def list_versions(self) -> list[str]: ...
    def delete(self, version: str) -> bool: ...
    def get_current(self) -> str: ...
```

**Task 4-2**：实现 LocalFileImageBackend
```python
class LocalFileImageBackend(ImageBackend):
    """本地文件存储（Phase 1）"""
    
    def __init__(self):
        self.images_dir = Path(settings.SKILL_IMAGES_DIR)
        self.max_versions = settings.SKILL_IMAGE_VERSIONS_TO_KEEP
    
    def save(self, container_id: str, version: str) -> str:
        """使用 docker save 保存为 tar 文件"""
        # commit + docker save
        pass
    
    def load(self, version: str) -> str:
        """从 tar 文件加载镜像"""
        # docker load
        pass
```

**Task 4-3**：清理旧版本
```python
def _cleanup_old_versions(self):
    versions = self.list_versions()
    if len(versions) > self.max_versions:
        for v in versions[:-self.max_versions]:
            self.delete(v)
```

**Task 4-4**：回滚机制
```python
def rollback(self, target_version: str) -> list[str]:
    # 1. 加载目标版本镜像
    # 2. 更新当前版本
    # 3. 标记受影响的 skill
    # 4. 返回受影响 skill 列表
    pass
```

### 5.4 验收标准

- [ ] commit 正确创建新版本
- [ ] 旧版本正确清理（保留 5 个）
- [ ] 回滚功能正常
- [ ] 受影响的 skill 被正确标记

### 5.5 测试

```python
def test_image_manager():
    # 测试版本递增
    v1 = manager.get_current_version()
    manager.commit_new_version(container_id)
    v2 = manager.get_current_version()
    assert v2 > v1
    
    # 测试清理旧版本
    # ...
```

---

## 六、Phase 5：Skill 管理器 + Admin API

### 6.1 目标

- 实现 Skill CRUD
- 实现状态流转
- 实现文件操作
- 实现 Admin API 端点

### 6.2 文件变更

```
src/skill_manager.py  # 新增
api/admin.py          # 新增
api/models.py         # 修改
main.py               # 修改（注册路由）
```

### 6.3 具体任务

**Task 5-1**：创建 Skill 管理器
```python
class SkillManager:
    async def upload(self, file: UploadFile, admin_id: str) -> Skill:
        pass
    
    async def approve(self, skill_id: str, admin_id: str) -> Skill:
        pass
    
    async def reject(self, skill_id: str, admin_id: str, reason: str) -> Skill:
        pass
    
    async def delete(self, skill_id: str) -> bool:
        pass
```

**Task 5-2**：实现状态流转
```python
def can_transition(current: str, target: str) -> bool:
    transitions = {
        "pending": ["validating", "approved", "rejected"],
        "validating": ["pending", "rejected"],
        "approved": ["deleted"],
        "rejected": ["validating", "deleted"],
    }
    return target in transitions.get(current, [])
```

**Task 5-3**：创建 Admin API
```python
# api/admin.py

router = APIRouter(prefix="/api/admin", tags=["admin"])

@router.post("/skills/upload")
async def upload_skill(file: UploadFile, admin: str = Depends(get_admin_user)):
    pass

@router.post("/skills/{skill_id}/approve")
async def approve_skill(skill_id: str, admin: str = Depends(get_admin_user)):
    pass

# ... 其他端点
```

**Task 5-4**：添加 Pydantic 模型
```python
# api/models.py

class SkillListItem(BaseModel):
    ...

class ValidationReport(BaseModel):
    ...
```

### 6.4 验收标准

- [ ] 所有 API 端点正常工作
- [ ] 权限验证正确
- [ ] 状态流转正确
- [ ] 文件操作正确

### 6.5 测试

```python
def test_admin_api():
    # 测试上传
    resp = client.post("/api/admin/skills/upload", files=...)
    assert resp.status_code == 200
    
    # 测试批准
    resp = client.post(f"/api/admin/skills/{skill_id}/approve")
    assert resp.status_code == 200
```

---

## 七、Phase 6：集成测试

### 7.1 目标

- 端到端测试
- 性能测试
- 回归测试

### 7.2 文件变更

```
tests/skill_admin/               # 测试包目录
├── __init__.py                  # 包初始化
├── conftest.py                  # 共享配置和 fixtures
├── test_auth.py                 # 认证与授权测试 (3 个)
├── test_upload.py               # Skill 上传测试 (4 个)
├── test_list.py                 # Skill 列表测试 (3 个)
├── test_retrieval.py            # Skill 详情测试 (2 个)
├── test_validation.py           # Skill 验证测试 (3 个)
├── test_approval.py             # Skill 批准测试 (2 个)
├── test_rejection.py            # Skill 拒绝测试 (3 个)
├── test_deletion.py             # Skill 删除测试 (2 个)
├── test_report.py               # 验证报告测试 (2 个)
└── run_all.py                   # 运行所有测试的主入口
```

### 7.3 测试用例清单

#### 7.3.1 认证与授权测试 (3 个)

| 编号 | 测试场景 | 预期结果 |
|------|----------|----------|
| AUTH-01 | 非管理员用户访问管理端点 | 403 Forbidden |
| AUTH-02 | 无 Token 访问管理端点 | 401 Unauthorized |
| AUTH-03 | 无效 Token 访问管理端点 | 401 Unauthorized |

#### 7.3.2 Skill 上传测试 (4 个)

| 编号 | 测试场景 | 预期结果 |
|------|----------|----------|
| UPLOAD-01 | 上传有效的 Skill ZIP | 200, 返回 skill_id |
| UPLOAD-02 | 上传非 ZIP 文件 | 400, "must be a ZIP file" |
| UPLOAD-03 | 上传无 SKILL.md 的 ZIP | 200, format_valid=false, 错误信息包含 SKILL.md |
| UPLOAD-04 | 上传空 SKILL.md 的 ZIP | 200, format_valid=false |

#### 7.3.3 Skill 列表测试 (3 个)

| 编号 | 测试场景 | 预期结果 |
|------|----------|----------|
| LIST-01 | 列出所有 skills | 200, 返回 skills 数组和 total |
| LIST-02 | 按 status 筛选 skills | 200, 只返回指定状态的 skills |
| LIST-03 | 筛选不存在的 status | 200, skills=[] |

#### 7.3.4 Skill 详情测试 (2 个)

| 编号 | 测试场景 | 预期结果 |
|------|----------|----------|
| GET-01 | 获取存在的 skill 详情 | 200, 返回完整 skill 信息 |
| GET-02 | 获取不存在的 skill | 404, "not found" |

#### 7.3.5 Skill 验证测试 (3 个)

| 编号 | 测试场景 | 预期结果 |
|------|----------|----------|
| VAL-01 | 启动验证 | 200, 验证开始 |
| VAL-02 | 验证不存在的 skill | 404 |
| VAL-03 | 验证非 pending 状态的 skill | 400, "Cannot validate skill with status" |

#### 7.3.6 Skill 批准测试 (2 个)

| 编号 | 测试场景 | 预期结果 |
|------|----------|----------|
| APPROVE-01 | 批准不存在的 skill | 400/404 |
| APPROVE-02 | 批准未完成验证的 skill | 400, "validation not completed" |

#### 7.3.7 Skill 拒绝测试 (3 个)

| 编号 | 测试场景 | 预期结果 |
|------|----------|----------|
| REJECT-01 | 拒绝存在的 skill | 200, status 变为 rejected |
| REJECT-02 | 拒绝不存在的 skill | 400/404 |
| REJECT-03 | 拒绝时不提供 reason | 422, validation error |

#### 7.3.8 Skill 删除测试 (2 个)

| 编号 | 测试场景 | 预期结果 |
|------|----------|----------|
| DEL-01 | 删除存在的 skill | 200, 之后再获取返回 404 |
| DEL-02 | 删除不存在的 skill | 404 |

#### 7.3.9 验证报告测试 (2 个)

| 编号 | 测试场景 | 预期结果 |
|------|----------|----------|
| REPORT-01 | 获取待验证 skill 的报告 | 200, 返回 markdown 报告 |
| REPORT-02 | 获取不存在 skill 的报告 | 404 |

### 7.4 测试执行

```bash
# 运行所有 v0.1.9 测试 (推荐)
uv run python -m tests.skill_admin.run_all

# 或者直接运行
cd tests/skill_admin && uv run python run_all.py

# 运行单个测试模块
uv run python -m tests.skill_admin.test_auth
uv run python -m tests.skill_admin.test_upload
uv run python -m tests.skill_admin.test_list
# ... 其他模块

# 测试覆盖率
# 预期: 24 个测试用例全部通过
```

### 7.5 测试包结构说明

| 文件 | 测试模块 | 测试数量 |
|------|----------|----------|
| test_auth.py | 认证与授权 | 3 |
| test_upload.py | Skill 上传 | 4 |
| test_list.py | Skill 列表 | 3 |
| test_retrieval.py | Skill 详情 | 2 |
| test_validation.py | Skill 验证 | 3 |
| test_approval.py | Skill 批准 | 2 |
| test_rejection.py | Skill 拒绝 | 3 |
| test_deletion.py | Skill 删除 | 2 |
| test_report.py | 验证报告 | 2 |
| **合计** | | **24** |

### 7.5 验收标准

- [ ] 24 个测试用例全部通过
- [ ] 覆盖所有 API 端点
- [ ] 覆盖所有错误场景
- [ ] 无回归问题

---

## 九、每日进度跟踪

### Day 1

| 任务 | 预计 | 实际 | 状态 |
|------|------|------|------|
| Phase 1: 数据库模型 + 格式验证 | 0.5天 | - | pending |

### Day 2

| 任务 | 预计 | 实际 | 状态 |
|------|------|------|------|
| Phase 2: 第一层验证 | 1天 | - | pending |

### Day 3

| 任务 | 预计 | 实际 | 状态 |
|------|------|------|------|
| Phase 3: 第二层验证（并行回归） | 1天 | - | pending |

### Day 4

| 任务 | 预计 | 实际 | 状态 |
|------|------|------|------|
| Phase 4: 增量镜像管理 | 0.5天 | - | pending |
| Phase 5: 管理器 + API | 0.5天 | - | pending |

### Day 5

| 任务 | 预计 | 实际 | 状态 |
|------|------|------|------|
| Phase 6: 集成测试 | 0.5天 | - | pending |
| 缓冲时间 | 0.5天 | - | pending |

---

## 十、风险与缓解

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| Docker 网络控制不稳定 | 高 | 中 | 添加重试机制，记录详细日志 |
| 并行回归资源消耗大 | 中 | 中 | 限制并发数，添加资源监控 |
| Agent 依赖安装失败 | 中 | 低 | Agent 智能重试，支持手动干预 |
| 镜像 commit 失败 | 高 | 低 | 保留容器快照，支持手动恢复 |
| 报告生成 Agent 输出不稳定 | 低 | 中 | 提供详细模板，多次生成取最佳 |

---

## 十一、发布检查清单

### 功能检查

- [ ] 管理员可上传 Skill zip
- [ ] 格式验证正确
- [ ] 第一层验证正常
- [ ] 第二层并行回归正常
- [ ] 验证报告完整
- [ ] 批准/拒绝功能正常
- [ ] 镜像版本管理正常
- [ ] 回滚功能正常

### 性能检查

- [ ] 单个 skill 验证时间 < 5 分钟
- [ ] 并行回归效率提升
- [ ] 内存占用合理

### 安全检查

- [ ] 权限验证正确
- [ ] 无敏感信息泄露
- [ ] Docker 沙箱隔离有效

### 文档检查

- [ ] API 文档完整
- [ ] 部署文档完整
- [ ] 运维文档完整
