# 前端对接指南

> 基于 Vue 3 + TypeScript + Vuetify 的文件管理对接方案

---

## 一、架构说明

### 1.1 文件同步机制

v0.1.6 后，WebDAV 和 Agent 共享同一用户目录：

```
workspaces/{user_id}/
├── project/
│   └── main.py          <- WebDAV 上传，Agent 立即可见
├── data.csv             <- Agent 创建，WebDAV 立即可见
└── output.txt           <- 两者操作同一文件
```

**关键特性**：
- ✅ 用户上传文件后，Agent 立即可见可操作
- ✅ Agent 创建的文件，用户可在前端直接下载
- ✅ 无需中转目录，操作同一 `/workspace`

### 1.2 API 端点

| 端点 | 方法 | 用途 |
|------|------|------|
| `/dav/{path}` | PROPFIND | 列目录/获取属性 |
| `/dav/{path}` | GET | 下载文件 |
| `/dav/{path}` | PUT | 上传文件 |
| `/dav/{path}` | MKCOL | 创建目录 |
| `/dav/{path}` | DELETE | 删除 |
| `/dav/{path}` | MOVE | 移动/重命名 |
| `/api/files/init-upload` | POST | 分片上传初始化 |
| `/api/files/upload-chunk` | POST | 上传分片 |
| `/api/files/complete-upload` | POST | 合并分片 |

---

## 二、依赖安装

```bash
npm install webdav axios
```

---

## 三、TypeScript 类型定义

```typescript
// src/types/file.ts

export interface FileItem {
  name: string
  path: string
  type: 'file' | 'directory'
  size: number | null
  modified: string | null
  etag: string | null
}

export interface UploadProgress {
  loaded: number
  total: number
  percentage: number
}

export interface ChunkUploadProgress {
  chunkIndex: number
  totalChunks: number
  percentage: number
}

export interface InitUploadResponse {
  upload_id: string
  chunk_size: number
}

export interface WebDAVClient {
  listDirectory(path: string): Promise<FileItem[]>
  uploadFile(path: string, file: File, onProgress?: (p: UploadProgress) => void): Promise<void>
  downloadFile(path: string): Promise<Blob>
  createDirectory(path: string): Promise<void>
  deleteItem(path: string): Promise<void>
  moveItem(src: string, dst: string): Promise<void>
  uploadLargeFile(path: string, file: File, onProgress?: (p: ChunkUploadProgress) => void): Promise<void>
}
```

---

## 四、WebDAV 客户端封装

```typescript
// src/services/fileService.ts
import { createClient, WebDAVClient as WebDAVClientLib } from 'webdav'
import axios from 'axios'
import type { FileItem, UploadProgress, ChunkUploadProgress, InitUploadResponse, WebDAVClient } from '@/types/file'

const CHUNK_SIZE = 10 * 1024 * 1024 // 10MB
const LARGE_FILE_THRESHOLD = 100 * 1024 * 1024 // 100MB

class FileServiceImpl implements WebDAVClient {
  private client: WebDAVClientLib
  private token: string

  constructor() {
    this.token = localStorage.getItem('token') || ''
    this.client = createClient('/dav', {
      headers: {
        Authorization: `Bearer ${this.token}`
      }
    })
  }

  updateToken(token: string) {
    this.token = token
    this.client = createClient('/dav', {
      headers: {
        Authorization: `Bearer ${this.token}`
      }
    })
  }

  async listDirectory(path: string = '/'): Promise<FileItem[]> {
    const items = await this.client.getDirectoryContents(path)
    
    if (!Array.isArray(items)) {
      return []
    }

    return items.map(item => ({
      name: item.basename,
      path: item.filename,
      type: item.type as 'file' | 'directory',
      size: item.size ?? null,
      modified: item.lastmod ?? null,
      etag: item.etag ?? null
    }))
  }

  async uploadFile(
    path: string, 
    file: File, 
    onProgress?: (p: UploadProgress) => void
  ): Promise<void> {
    const content = await file.arrayBuffer()
    
    await this.client.putFileContents(path, content, {
      onUploadProgress: progress => {
        if (onProgress && progress.total) {
          onProgress({
            loaded: progress.loaded,
            total: progress.total,
            percentage: Math.round((progress.loaded / progress.total) * 100)
          })
        }
      }
    })
  }

  async downloadFile(path: string): Promise<Blob> {
    const content = await this.client.getFileContents(path, { format: 'blob' })
    return content as Blob
  }

  async createDirectory(path: string): Promise<void> {
    await this.client.createDirectory(path)
  }

  async deleteItem(path: string): Promise<void> {
    await this.client.deleteFile(path)
  }

  async moveItem(src: string, dst: string): Promise<void> {
    await this.client.moveFile(src, dst)
  }

  // 大文件分片上传
  async uploadLargeFile(
    path: string, 
    file: File, 
    onProgress?: (p: ChunkUploadProgress) => void
  ): Promise<void> {
    const totalChunks = Math.ceil(file.size / CHUNK_SIZE)

    // 1. 初始化
    const initRes = await axios.post<InitUploadResponse>('/api/files/init-upload', {
      filename: file.name,
      total_chunks: totalChunks,
      total_size: file.size,
      target_path: path
    }, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.token}`
      }
    })

    const uploadId = initRes.data.upload_id

    // 2. 分片上传
    for (let i = 0; i < totalChunks; i++) {
      const start = i * CHUNK_SIZE
      const end = Math.min(start + CHUNK_SIZE, file.size)
      const chunk = file.slice(start, end)

      const formData = new FormData()
      formData.append('upload_id', uploadId)
      formData.append('chunk_index', String(i))
      formData.append('chunk', chunk)

      await axios.post('/api/files/upload-chunk', formData, {
        headers: {
          'Authorization': `Bearer ${this.token}`
        }
      })

      onProgress?.({
        chunkIndex: i + 1,
        totalChunks,
        percentage: Math.round(((i + 1) / totalChunks) * 100)
      })
    }

    // 3. 完成
    await axios.post('/api/files/complete-upload', {
      upload_id: uploadId,
      target_path: path
    }, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.token}`
      }
    })
  }

  // 智能上传（自动选择分片或直传）
  async smartUpload(
    path: string, 
    file: File, 
    onProgress?: (p: UploadProgress | ChunkUploadProgress) => void
  ): Promise<void> {
    if (file.size > LARGE_FILE_THRESHOLD) {
      return this.uploadLargeFile(path, file, onProgress as (p: ChunkUploadProgress) => void)
    } else {
      return this.uploadFile(path, file, onProgress as (p: UploadProgress) => void)
    }
  }
}

export const fileService = new FileServiceImpl()
```

---

## 五、Vue 组件示例

### 5.1 文件列表组件

```vue
<!-- src/components/FileExplorer.vue -->
<template>
  <v-card>
    <v-card-title class="d-flex align-center">
      <v-icon start>mdi-folder</v-icon>
      文件管理
      <v-spacer />
      <v-btn color="primary" prepend-icon="mdi-upload" @click="uploadDialog = true">
        上传
      </v-btn>
      <v-btn color="secondary" prepend-icon="mdi-folder-plus" @click="createDirDialog = true">
        新建文件夹
      </v-btn>
    </v-card-title>

    <v-breadcrumbs :items="breadcrumbs" class="px-4">
      <template v-slot:item="{ item }">
        <v-breadcrumbs-item @click="navigateTo(item.path)">
          {{ item.title }}
        </v-breadcrumbs-item>
      </template>
    </v-breadcrumbs>

    <v-divider />

    <v-list v-if="!loading" density="compact">
      <v-list-item
        v-for="item in files"
        :key="item.path"
        @click="item.type === 'directory' ? navigateTo(item.path) : null"
      >
        <template v-slot:prepend>
          <v-icon :color="item.type === 'directory' ? 'amber' : 'blue'">
            {{ item.type === 'directory' ? 'mdi-folder' : 'mdi-file' }}
          </v-icon>
        </template>

        <v-list-item-title>{{ item.name }}</v-list-item-title>
        <v-list-item-subtitle>
          {{ item.size ? formatSize(item.size) : '' }}
          {{ item.modified ? formatDate(item.modified) : '' }}
        </v-list-item-subtitle>

        <template v-slot:append>
          <v-btn icon="mdi-download" variant="text" size="small" 
                 @click.stop="downloadFile(item)" v-if="item.type === 'file'" />
          <v-btn icon="mdi-delete" variant="text" size="small" color="error"
                 @click.stop="confirmDelete(item)" />
        </template>
      </v-list-item>

      <v-list-item v-if="files.length === 0">
        <v-list-item-title class="text-center text-grey">
          暂无文件
        </v-list-item-title>
      </v-list-item>
    </v-list>

    <v-progress-circular v-else indeterminate class="ma-4" />

    <!-- 上传对话框 -->
    <v-dialog v-model="uploadDialog" max-width="500">
      <v-card>
        <v-card-title>上传文件</v-card-title>
        <v-card-text>
          <v-file-input v-model="uploadFile" label="选择文件" />
          <v-progress-linear 
            v-if="uploading" 
            :model-value="uploadProgress" 
            class="mt-2"
          />
        </v-card-text>
        <v-card-actions>
          <v-spacer />
          <v-btn @click="uploadDialog = false">取消</v-btn>
          <v-btn color="primary" @click="handleUpload" :loading="uploading">上传</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>

    <!-- 新建文件夹对话框 -->
    <v-dialog v-model="createDirDialog" max-width="400">
      <v-card>
        <v-card-title>新建文件夹</v-card-title>
        <v-card-text>
          <v-text-field v-model="newDirName" label="文件夹名称" />
        </v-card-text>
        <v-card-actions>
          <v-spacer />
          <v-btn @click="createDirDialog = false">取消</v-btn>
          <v-btn color="primary" @click="handleCreateDir">创建</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>

    <!-- 删除确认 -->
    <v-dialog v-model="deleteDialog" max-width="400">
      <v-card>
        <v-card-title>确认删除</v-card-title>
        <v-card-text>确定要删除 "{{ deleteTarget?.name }}" 吗？</v-card-text>
        <v-card-actions>
          <v-spacer />
          <v-btn @click="deleteDialog = false">取消</v-btn>
          <v-btn color="error" @click="handleDelete">删除</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>
  </v-card>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue'
import { fileService } from '@/services/fileService'
import type { FileItem, UploadProgress } from '@/types/file'

const currentPath = ref('/')
const files = ref<FileItem[]>([])
const loading = ref(false)

// 上传相关
const uploadDialog = ref(false)
const uploadFile = ref<File | null>(null)
const uploading = ref(false)
const uploadProgress = ref(0)

// 新建文件夹
const createDirDialog = ref(false)
const newDirName = ref('')

// 删除确认
const deleteDialog = ref(false)
const deleteTarget = ref<FileItem | null>(null)

// 面包屑导航
const breadcrumbs = computed(() => {
  const parts = currentPath.value.split('/').filter(Boolean)
  const items = [{ title: '根目录', path: '/' }]
  let path = ''
  for (const part of parts) {
    path += '/' + part
    items.push({ title: part, path })
  }
  return items
})

// 加载文件列表
async function loadFiles() {
  loading.value = true
  try {
    files.value = await fileService.listDirectory(currentPath.value)
  } catch (error) {
    console.error('Failed to load files:', error)
  } finally {
    loading.value = false
  }
}

// 导航
function navigateTo(path: string) {
  currentPath.value = path
  loadFiles()
}

// 上传
async function handleUpload() {
  if (!uploadFile.value) return
  
  uploading.value = true
  uploadProgress.value = 0
  
  try {
    const targetPath = currentPath.value === '/' 
      ? `/${uploadFile.value.name}` 
      : `${currentPath.value}/${uploadFile.value.name}`
    
    await fileService.smartUpload(targetPath, uploadFile.value, (p) => {
      uploadProgress.value = p.percentage
    })
    
    uploadDialog.value = false
    uploadFile.value = null
    await loadFiles()
  } catch (error) {
    console.error('Upload failed:', error)
  } finally {
    uploading.value = false
  }
}

// 下载
async function downloadFile(item: FileItem) {
  try {
    const blob = await fileService.downloadFile(item.path)
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = item.name
    a.click()
    URL.revokeObjectURL(url)
  } catch (error) {
    console.error('Download failed:', error)
  }
}

// 新建文件夹
async function handleCreateDir() {
  if (!newDirName.value) return
  
  try {
    const dirPath = currentPath.value === '/' 
      ? `/${newDirName.value}` 
      : `${currentPath.value}/${newDirName.value}`
    
    await fileService.createDirectory(dirPath)
    createDirDialog.value = false
    newDirName.value = ''
    await loadFiles()
  } catch (error) {
    console.error('Create directory failed:', error)
  }
}

// 删除
function confirmDelete(item: FileItem) {
  deleteTarget.value = item
  deleteDialog.value = true
}

async function handleDelete() {
  if (!deleteTarget.value) return
  
  try {
    await fileService.deleteItem(deleteTarget.value.path)
    deleteDialog.value = false
    deleteTarget.value = null
    await loadFiles()
  } catch (error) {
    console.error('Delete failed:', error)
  }
}

// 工具函数
function formatSize(bytes: number): string {
  if (bytes < 1024) return bytes + ' B'
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB'
  if (bytes < 1024 * 1024 * 1024) return (bytes / 1024 / 1024).toFixed(1) + ' MB'
  return (bytes / 1024 / 1024 / 1024).toFixed(1) + ' GB'
}

function formatDate(dateStr: string): string {
  return new Date(dateStr).toLocaleString('zh-CN')
}

onMounted(() => {
  loadFiles()
})
</script>
```

### 5.2 与 Agent 对话集成

```vue
<!-- src/components/AgentChat.vue -->
<template>
  <v-card>
    <v-card-title>
      <v-icon start>mdi-robot</v-icon>
      AI 助手
    </v-card-title>
    
    <v-card-text>
      <v-alert type="info" variant="tonal" class="mb-4">
        AI 助手可以操作您的文件。上传的文件会被 AI 自动识别并可操作。
      </v-alert>

      <div class="messages-container" ref="messagesContainer">
        <div 
          v-for="(msg, i) in messages" 
          :key="i" 
          :class="['message', msg.role]"
        >
          <div class="message-content">{{ msg.content }}</div>
        </div>
      </div>

      <v-textarea
        v-model="inputMessage"
        label="输入消息"
        rows="2"
        auto-grow
        @keydown.enter.ctrl="sendMessage"
      />
    </v-card-text>

    <v-card-actions>
      <v-spacer />
      <v-btn color="primary" @click="sendMessage" :loading="sending">
        发送
      </v-btn>
    </v-card-actions>
  </v-card>
</template>

<script setup lang="ts">
import { ref, nextTick } from 'vue'
import axios from 'axios'

interface Message {
  role: 'user' | 'assistant'
  content: string
}

const messages = ref<Message[]>([])
const inputMessage = ref('')
const sending = ref(false)
const messagesContainer = ref<HTMLElement | null>(null)
const threadId = ref<string | null>(null)

const token = localStorage.getItem('token') || ''

async function sendMessage() {
  if (!inputMessage.value.trim()) return
  
  const userMessage = inputMessage.value
  inputMessage.value = ''
  
  messages.value.push({ role: 'user', content: userMessage })
  
  sending.value = true
  
  try {
    // 如果没有 threadId，先创建
    if (!threadId.value) {
      const sessionRes = await axios.post('/api/sessions', {}, {
        headers: { Authorization: `Bearer ${token}` }
      })
      threadId.value = sessionRes.data.thread_id
    }

    // 发送消息
    const response = await fetch(`/api/chat/${threadId.value}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({ message: userMessage })
    })

    // 处理 SSE 流
    const reader = response.body?.getReader()
    let assistantContent = ''

    while (reader) {
      const { done, value } = await reader.read()
      if (done) break

      const text = new TextDecoder().decode(value)
      const lines = text.split('\n')

      for (const line of lines) {
        if (line.startsWith('data:')) {
          try {
            const data = JSON.parse(line.slice(5))
            if (data.content) {
              assistantContent += data.content
            }
          } catch {
            // 忽略解析错误
          }
        }
      }
    }

    if (assistantContent) {
      messages.value.push({ role: 'assistant', content: assistantContent })
    }

    nextTick(() => {
      messagesContainer.value?.scrollTo({
        top: messagesContainer.value?.scrollHeight,
        behavior: 'smooth'
      })
    })

  } catch (error) {
    console.error('Failed to send message:', error)
  } finally {
    sending.value = false
  }
}
</script>

<style scoped>
.messages-container {
  max-height: 400px;
  overflow-y: auto;
  margin-bottom: 16px;
}

.message {
  margin-bottom: 12px;
  padding: 8px 12px;
  border-radius: 8px;
}

.message.user {
  background-color: rgb(var(--v-theme-primary));
  margin-left: 40px;
}

.message.assistant {
  background-color: rgb(var(--v-theme-surface-variant));
  margin-right: 40px;
}

.message-content {
  white-space: pre-wrap;
  word-break: break-word;
}
</style>
```

---

## 六、使用示例

### 6.1 在页面中组合使用

```vue
<!-- src/views/Workspace.vue -->
<template>
  <v-container fluid>
    <v-row>
      <!-- 左侧：文件管理 -->
      <v-col cols="12" md="6">
        <FileExplorer />
      </v-col>
      
      <!-- 右侧：AI 对话 -->
      <v-col cols="12" md="6">
        <AgentChat />
      </v-col>
    </v-row>
    
    <v-row>
      <v-col>
        <v-alert type="success" variant="tonal">
          <strong>文件同步</strong>：您上传的文件会立即同步到 AI 工作目录，
          AI 创建的文件也会立即出现在文件列表中。
        </v-alert>
      </v-col>
    </v-row>
  </v-container>
</template>

<script setup lang="ts">
import FileExplorer from '@/components/FileExplorer.vue'
import AgentChat from '@/components/AgentChat.vue'
</script>
```

---

## 七、注意事项

### 7.1 认证

所有请求必须携带 JWT Token：

```typescript
const token = localStorage.getItem('token')
// 或从 Pinia/Vuex store 获取
```

### 7.2 错误处理

| HTTP 状态码 | 说明 | 处理方式 |
|------------|------|----------|
| 401 | 未授权 | 跳转登录页 |
| 403 | 无权限 | 提示无权限 |
| 404 | 文件不存在 | 刷新文件列表 |
| 409 | ETag 冲突 | 提示文件已被修改 |
| 500 | 服务器错误 | 提示稍后重试 |

### 7.3 大文件上传

- **< 100MB**：直接使用 WebDAV PUT
- **>= 100MB**：使用分片上传 API

### 7.4 与 Agent 同步

上传文件后，可直接对 AI 说：
- "帮我分析 /data.csv 文件"
- "读取 /project/main.py 并优化代码"

AI 会立即看到用户上传的文件。
