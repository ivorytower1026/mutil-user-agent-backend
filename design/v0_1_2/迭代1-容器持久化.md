# 迭代1：容器持久化

## 一、现象（实际）

### 当前行为

**文件**: `src/docker_sandbox.py:48-66`

```python
def execute(self, command: str) -> ExecuteResponse:
    container = None
    try:
        container = self._create_container()  # 每次execute都创建新容器
        container.start()

        exit_code, output = container.exec_run(
            cmd=["/bin/bash", "-lc", command],
            workdir=settings.CONTAINER_WORKSPACE_DIR,
        )

        return ExecuteResponse(
            output=output.decode('utf-8'),
            exit_code=exit_code,
            truncated=False
        )
    finally:
        if container:
            container.remove(force=True)  # 每次execute后都销毁容器
```

### 问题表现

1. **状态丢失**：每次execute后容器销毁，无法保持文件状态
   ```
   execute("mkdir /workspace/data")  # 创建目录
   execute("ls /workspace")          # 看不到data目录（容器已重建）
   ```

2. **性能浪费**：每次execute都要创建/启动/销毁容器
   - 容器创建耗时：约1-2秒
   - 频繁创建销毁增加Docker daemon负担

3. **无法支持多步骤任务**：Agent的多步操作需要状态延续
   ```
   step1: pip install pandas
   step2: import pandas  # 失败！容器已重建
   ```

---

## 二、意图（期望）

### 目标行为

1. **容器复用**：同一个thread_id的多次execute复用同一容器
   ```python
   backend = get_thread_backend("user1-abc123")
   backend.execute("mkdir /workspace/data")  # 创建容器A
   backend.execute("ls /workspace")          # 复用容器A，能看到data
   backend.execute("pip install pandas")     # 复用容器A
   backend.execute("python -c 'import pandas'")  # 复用容器A，pandas已安装
   ```

2. **显式销毁**：通过API调用显式销毁容器
   ```
   DELETE /api/sessions/{thread_id}
   ```

3. **懒加载创建**：首次execute时才创建容器

### 期望架构

```
┌─────────────────────────────────────────────────────────────┐
│                    _thread_backends (dict)                  │
│  key: thread_id        value: DockerSandboxBackend         │
│  ┌─────────────────┐  ┌─────────────────────────────────┐  │
│  │ user1-abc123    │─▶│ _container: Container (持久化)   │  │
│  │ user2-def456    │─▶│ _container: Container (持久化)   │  │
│  └─────────────────┘  └─────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

---

## 三、情境（环境约束）

### 技术约束

| 约束项 | 说明 |
|--------|------|
| Python版本 | 3.13+ |
| Docker SDK | `docker` Python包 |
| 现有架构 | 继承 `deepagents.backends.sandbox.BaseSandbox` |
| 异步环境 | FastAPI异步，但Docker SDK是同步的 |

### 兼容性约束

1. **接口兼容**：必须保持 `execute()` 方法签名不变
   ```python
   def execute(self, command: str) -> ExecuteResponse:
       # 签名不能变
   ```

2. **工厂函数兼容**：`get_thread_backend()` 返回类型不变
   ```python
   def get_thread_backend(thread_id: str) -> DockerSandboxBackend:
       # 返回类型不变
   ```

3. **现有测试通过**：`tests/test_v0_1_1.py` 和 `tests/test_mvp.py` 必须继续通过

### 资源约束

| 资源 | 当前配置 | 约束 |
|------|---------|------|
| 最大容器数 | 无限制 | 建议不超过100个并发 |
| 容器内存 | 无限制 | 默认镜像约50MB |
| 容器CPU | 无限制 | - |

### 运行环境

- Docker Desktop 或 Docker Engine
- Windows/Linux/macOS
- 容器镜像：`python:3.13-slim`

---

## 四、边界（明确不做）

### 本迭代不做

| 不做项 | 原因 | 计划迭代 |
|--------|------|---------|
| 容器池预热 | 复杂度高，先验证持久化可行性 | 迭代4（可选） |
| 自动超时清理 | 需要后台任务调度 | 迭代4（可选） |
| 资源限制（CPU/内存） | 非核心功能 | 迭代5（可选） |
| 多容器负载均衡 | 过度设计 | 不做 |
| 容器监控/日志 | 非核心功能 | 后续版本 |
| 容器状态持久化到数据库 | 简化实现，内存管理足够 | 不做 |

### 明确排除的场景

1. **跨进程容器共享**：不支持多进程共享同一容器实例
2. **容器快照/恢复**：不做容器状态保存
3. **容器迁移**：不做容器在不同主机间迁移

---

## 五、详细设计

### 5.1 类图

```
┌─────────────────────────────────────────────────────────────┐
│                    DockerSandboxBackend                      │
├─────────────────────────────────────────────────────────────┤
│ - thread_id: str                                            │
│ - workspace_dir: str                                        │
│ - image: str                                                │
│ - client: DockerClient                                      │
│ - _container: Container | None  ◀── 新增：持久化容器        │
├─────────────────────────────────────────────────────────────┤
│ + id() -> str                                               │
│ + execute(command: str) -> ExecuteResponse                  │
│ + upload_files(files) -> list                               │
│ + download_files(paths) -> list                             │
│ + destroy() -> None                    ◀── 新增：显式销毁   │
│ - _ensure_container() -> Container    ◀── 新增：懒加载     │
│ - _create_container() -> Container                          │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 状态流转

```
┌─────────┐     execute()      ┌──────────┐     destroy()     ┌─────────┐
│  初始   │ ─────────────────▶ │ 运行中   │ ────────────────▶ │ 已销毁  │
│(无容器) │                    │(有容器)  │                   │(无容器) │
└─────────┘                    └──────────┘                   └─────────┘
     │                              │
     │                              │ execute()
     │                              │ (复用容器)
     │                              ▼
     │                         ┌──────────┐
     │                         │ 运行中   │
     │                         └──────────┘
     │
     │ destroy()
     │ (无操作)
     ▼
┌─────────┐
│ 已销毁  │
└─────────┘
```

### 5.3 代码改动

#### 5.3.1 `src/docker_sandbox.py`

```python
import os
import docker
from pathlib import Path
from deepagents.backends.sandbox import BaseSandbox
from deepagents.backends.protocol import (
    ExecuteResponse,
    FileUploadResponse,
    FileDownloadResponse
)
from src.config import settings


_thread_backends = {}


def get_thread_backend(thread_id: str) -> 'DockerSandboxBackend':
    """Get or create a thread backend.
    
    Workspace directory structure: workspaces/{user_id}/{thread_id}/
    where thread_id format is {user_id}-{uuid}
    """
    if thread_id not in _thread_backends:
        user_id = thread_id.split('-')[0]
        
        workspace_dir = os.path.join(
            Path(settings.WORKSPACE_ROOT).expanduser().absolute(),
            user_id,
            thread_id
        )
        os.makedirs(workspace_dir, exist_ok=True)
        _thread_backends[thread_id] = DockerSandboxBackend(thread_id, workspace_dir)
    return _thread_backends[thread_id]


def destroy_thread_backend(thread_id: str) -> bool:
    """Destroy a thread backend and its container.
    
    Returns:
        True if destroyed, False if not found
    """
    if thread_id in _thread_backends:
        _thread_backends[thread_id].destroy()
        del _thread_backends[thread_id]
        return True
    return False


class DockerSandboxBackend(BaseSandbox):
    """Docker-based sandbox backend with persistent container.
    
    Changes from original:
    - Container is created on first execute() and reused
    - Container must be explicitly destroyed via destroy() or destroy_thread_backend()
    """
    
    def __init__(self, thread_id: str, workspace_dir: str):
        self.thread_id = thread_id
        self.workspace_dir = workspace_dir
        self.image = settings.DOCKER_IMAGE
        self.client = docker.from_env()
        self._container: docker.models.containers.Container | None = None

    @property
    def id(self) -> str:
        return self.thread_id

    def _ensure_container(self) -> docker.models.containers.Container:
        """Ensure container exists and is running (lazy initialization).
        
        Creates container on first call, returns existing container on subsequent calls.
        """
        if self._container is None:
            self._container = self._create_container()
            self._container.start()
            print(f"[DockerSandbox] Created container for thread {self.thread_id}")
        return self._container

    def execute(self, command: str) -> ExecuteResponse:
        """Execute a command in the sandbox.
        
        Container is created on first call and reused for subsequent calls.
        """
        container = self._ensure_container()

        exit_code, output = container.exec_run(
            cmd=["/bin/bash", "-lc", command],
            workdir=settings.CONTAINER_WORKSPACE_DIR,
        )

        return ExecuteResponse(
            output=output.decode('utf-8'),
            exit_code=exit_code,
            truncated=False
        )

    def upload_files(self, files: list[tuple[str, bytes]]) -> list[FileUploadResponse]:
        """Upload files - files are written directly to workspace directory."""
        results = []
        for file_path, content in files:
            try:
                full_path = os.path.join(self.workspace_dir, file_path.lstrip('/'))
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                with open(full_path, 'wb') as f:
                    f.write(content)
                results.append(FileUploadResponse(path=file_path, error=None))
            except Exception as e:
                results.append(FileUploadResponse(path=file_path, error=str(e)))
        return results

    def download_files(self, paths: list[str]) -> list[FileDownloadResponse]:
        """Download files - files are read directly from workspace directory."""
        results = []
        for file_path in paths:
            try:
                full_path = os.path.join(self.workspace_dir, file_path.lstrip('/'))
                with open(full_path, 'rb') as f:
                    content = f.read()
                results.append(FileDownloadResponse(path=file_path, content=content, error=None))
            except Exception as e:
                results.append(FileDownloadResponse(path=file_path, content=None, error=str(e)))
        return results

    def destroy(self) -> None:
        """Destroy the container explicitly.
        
        Should be called when the session is no longer needed.
        Safe to call multiple times.
        """
        if self._container is not None:
            try:
                self._container.remove(force=True)
                print(f"[DockerSandbox] Destroyed container for thread {self.thread_id}")
            except docker.errors.APIError as e:
                print(f"[DockerSandbox] Warning: Failed to destroy container: {e}")
            finally:
                self._container = None

    def _create_container(self) -> docker.models.containers.Container:
        """Create a new container (does not start it)."""
        return self.client.containers.create(
            image=self.image,
            command="sleep infinity",
            working_dir=settings.CONTAINER_WORKSPACE_DIR,
            volumes={
                self.workspace_dir: {"bind": settings.CONTAINER_WORKSPACE_DIR, "mode": "rw"},
                str(Path(settings.SHARED_DIR).expanduser().absolute()): {
                    "bind": settings.CONTAINER_SHARED_DIR, 
                    "mode": "ro"
                }
            }
        )
```

#### 5.3.2 `api/server.py` - 新增端点

```python
@router.delete("/sessions/{thread_id}")
async def destroy_session(
    thread_id: str,
    user: str = Depends(get_current_user)
):
    """Destroy a session and its container.
    
    Args:
        thread_id: The session/thread ID to destroy
        
    Returns:
        Status message
        
    Raises:
        403: If user doesn't own this thread
        404: If thread doesn't exist
    """
    # 验证thread归属
    if not thread_id.startswith(f"{user}-"):
        raise HTTPException(status_code=403, detail="Not authorized to access this thread")
    
    from src.docker_sandbox import destroy_thread_backend
    
    destroyed = destroy_thread_backend(thread_id)
    
    if not destroyed:
        raise HTTPException(status_code=404, detail="Thread not found")
    
    return {"status": "destroyed", "thread_id": thread_id}
```

### 5.4 测试用例

```python
# tests/test_container_persistence.py

import pytest
from src.docker_sandbox import get_thread_backend, destroy_thread_backend, _thread_backends


def test_container_persistence():
    """测试容器在多次execute之间保持状态"""
    thread_id = "test-user-persistence-test"
    
    try:
        backend = get_thread_backend(thread_id)
        
        # 第一次execute：创建目录
        result1 = backend.execute("mkdir -p /workspace/test_dir")
        assert result1.exit_code == 0
        
        # 第二次execute：验证目录存在（如果容器被销毁，目录不存在）
        result2 = backend.execute("ls /workspace/test_dir")
        assert result2.exit_code == 0
        
        # 第三次execute：安装包
        result3 = backend.execute("pip install --quiet cowsay")
        assert result3.exit_code == 0
        
        # 第四次execute：使用已安装的包
        result4 = backend.execute("python -c 'import cowsay; print(\"ok\")'")
        assert result4.exit_code == 0
        assert "ok" in result4.output
        
    finally:
        destroy_thread_backend(thread_id)


def test_container_reuse():
    """测试同一thread_id复用同一容器"""
    thread_id = "test-user-reuse-test"
    
    try:
        backend = get_thread_backend(thread_id)
        
        # 获取第一次的容器ID
        backend.execute("echo test")
        container_id_1 = backend._container.id
        
        # 再次execute，应该复用同一容器
        backend.execute("echo test")
        container_id_2 = backend._container.id
        
        assert container_id_1 == container_id_2, "Container should be reused"
        
    finally:
        destroy_thread_backend(thread_id)


def test_destroy_session():
    """测试销毁会话"""
    thread_id = "test-user-destroy-test"
    
    # 创建并执行
    backend = get_thread_backend(thread_id)
    backend.execute("echo test")
    assert thread_id in _thread_backends
    assert backend._container is not None
    
    # 销毁
    destroyed = destroy_thread_backend(thread_id)
    assert destroyed is True
    assert thread_id not in _thread_backends
    assert backend._container is None
    
    # 再次销毁（幂等）
    destroyed_again = destroy_thread_backend(thread_id)
    assert destroyed_again is False
```

---

## 六、验收标准

### 功能验收

| 场景 | 预期结果 | 验证方法 |
|------|---------|---------|
| 多次execute | 复用同一容器 | 检查容器ID相同 |
| 状态保持 | 文件/pip包在后续execute可用 | 创建文件→读取文件 |
| 显式销毁 | DELETE请求后容器不存在 | `docker ps -a` 检查 |
| 重复销毁 | 不报错，返回False | 连续调用destroy |

### 回归验收

- [ ] `tests/test_v0_1_1.py` 全部通过
- [ ] `tests/test_mvp.py` 全部通过

### 性能验收

| 指标 | 当前 | 目标 |
|------|------|------|
| 首次execute | ~2秒 | ~2秒（无变化） |
| 后续execute | ~2秒 | ~0.1秒（复用容器） |

---

## 七、风险评估

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|---------|
| 容器泄漏（忘记销毁） | 中 | 内存/资源耗尽 | 迭代4添加自动清理 |
| 容器异常退出 | 低 | execute失败 | 添加健康检查和自动重建 |
| 并发创建竞争 | 低 | 重复创建 | 使用锁保护（如需要） |

---

## 八、实施步骤

1. **修改 `src/docker_sandbox.py`**
   - 添加 `_container` 属性
   - 添加 `_ensure_container()` 方法
   - 修改 `execute()` 使用 `_ensure_container()`
   - 添加 `destroy()` 方法
   - 添加 `destroy_thread_backend()` 函数

2. **修改 `api/server.py`**
   - 添加 `DELETE /api/sessions/{thread_id}` 端点

3. **编写测试**
   - 创建 `tests/test_container_persistence.py`
   - 运行回归测试

4. **验证**
   - 手动测试容器复用
   - 手动测试销毁功能
