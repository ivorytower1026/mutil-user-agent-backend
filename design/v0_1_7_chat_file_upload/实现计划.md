# 实现计划

## 核心需求

1. Agent 可感知用户上传的文件
2. 用户可在聊天窗口一次性上传 ≤5 个文件，每个 ≤50MB

---

## 后端变更（5 处改动）

| # | 文件 | 改动 |
|---|------|------|
| 1 | `api/models.py` | ChatRequest 增加 `files` 字段 |
| 2 | `api/files.py` | 新增 `upload-simple` 端点 |
| 3 | `src/agent_manager.py` | stream_chat 构建 SystemMessage |
| 4 | `src/agent_manager.py` | get_history 过滤文件 SystemMessage |
| 5 | `api/server.py` | chat 端点传递 files 参数 |

---

## 1. ChatRequest 增加 files 字段

**文件**: `api/models.py`

```python
class ChatRequest(BaseModel):
    message: str
    files: list[str] | None = None  # 容器内文件路径列表
```

---

## 2. 新增 upload-simple 端点

**文件**: `api/files.py`

```python
MAX_UPLOAD_SIZE = 50 * 1024 * 1024  # 50MB

@router.post("/upload-simple")
async def upload_simple(
    file: UploadFile = File(...),
    user_id: str = Depends(get_current_user)
):
    content = await file.read()
    
    if len(content) > MAX_UPLOAD_SIZE:
        raise HTTPException(
            status_code=413,
            detail="文件超过 50MB，请使用 WebDAV 上传到工作目录"
        )
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    uid = uuid.uuid4().hex[:8]
    ext = Path(file.filename).suffix if file.filename else ""
    new_filename = f"{timestamp}_{uid}{ext}"
    
    user_dir = Path(settings.WORKSPACE_ROOT) / user_id
    uploads_dir = user_dir / "uploads"
    uploads_dir.mkdir(parents=True, exist_ok=True)
    
    file_path = uploads_dir / new_filename
    file_path.write_bytes(content)
    
    return {
        "success": True,
        "path": f"/workspace/uploads/{new_filename}",
        "filename": file.filename,
        "size": len(content)
    }
```

---

## 3. stream_chat 构建消息列表

**文件**: `src/agent_manager.py`

### 3.1 新增导入

```python
from langchain_core.messages import HumanMessage, SystemMessage
```

### 3.2 修改签名

```python
async def stream_chat(
    self, 
    thread_id: str, 
    message: str, 
    files: list[str] | None = None
) -> AsyncIterator[str]:
```

### 3.3 构建消息

```python
# 在 agent_task 中，替换原来的 {"messages": [HumanMessage(content=message)]}
messages = []
if files:
    file_list = "\n".join(f"- {path}" for path in files)
    messages.append(SystemMessage(
        content=f"当前对话中用户已上传的文件：\n{file_list}"
    ))
messages.append(HumanMessage(content=message))

async for stream_mode, data in self.compiled_agent.astream(
    {"messages": messages},
    ...
):
```

---

## 4. get_history 过滤 SystemMessage

**文件**: `src/agent_manager.py`

在 `get_history` 方法的循环中增加过滤逻辑：

```python
for msg in messages:
    if hasattr(msg, "type"):
        msg_type = msg.type
        content = str(msg.content) if hasattr(msg, "content") and msg.content else ""
        
        # 过滤掉文件信息的 SystemMessage
        if msg_type == "system" and content.startswith("当前对话中用户已上传的文件："):
            continue
        
        # ... 后续逻辑不变
```

---

## 5. chat 端点传递 files

**文件**: `api/server.py`

```python
async def event_generator() -> AsyncGenerator[str, None]:
    async for chunk in agent_manager.stream_chat(
        thread_id, 
        request.message, 
        request.files
    ):
        yield chunk
```

---

## 消息流示例

```
前端发送:
{
  "message": "帮我分析这个文件",
  "files": ["/workspace/uploads/xxx.csv"]
}

LangGraph state:
[
    SystemMessage(content="当前对话中用户已上传的文件：\n- /workspace/uploads/xxx.csv"),
    HumanMessage(content="帮我分析这个文件")
]

历史接口返回（过滤后）:
{
  "messages": [
    {"role": "user", "content": "帮我分析这个文件"}
  ]
}
```

---

# 前端对接方案

> 前端项目路径: `D:\my_project\my_agent_project\mutil-user-agent-front`

## 前端变更清单（5 处改动）

| # | 文件 | 改动 |
|---|------|------|
| 1 | `src/types/file.ts` | 新增 `UploadSimpleResponse` 类型 |
| 2 | `src/api/chat.ts` | 新增 `uploadSimple` 函数 |
| 3 | `src/api/sse.ts` | `streamChat` 增加 `files` 参数 |
| 4 | `src/composables/useChatStream.ts` | `sendMessage` 增加文件处理逻辑 |
| 5 | `src/components/chat/ChatInput.vue` | 新增文件选择按钮和已选文件展示 |

---

## 1. 类型定义

**文件**: `src/types/file.ts`

```typescript
// 新增
export interface UploadSimpleResponse {
  success: boolean
  path: string        // 容器内路径: "/workspace/uploads/xxx.pdf"
  filename: string    // 原始文件名
  size: number
}

export const MAX_FILE_SIZE = 50 * 1024 * 1024  // 50MB
export const MAX_FILE_COUNT = 5
```

---

## 2. API 层

**文件**: `src/api/chat.ts`

```typescript
import type { UploadSimpleResponse } from '@/types/file'

export const chatApi = {
  // ... 现有方法保持不变

  async uploadSimple(file: File): Promise<UploadSimpleResponse> {
    const formData = new FormData()
    formData.append('file', file)
    
    const response = await api.post<UploadSimpleResponse>('/api/files/upload-simple', formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    })
    return response.data
  }
}
```

---

## 3. SSE 层

**文件**: `src/api/sse.ts`

```typescript
// 修改 streamChat 函数签名
export async function* streamChat(
  threadId: string,
  message: string,
  files?: string[],  // 新增参数
  signal?: AbortSignal
): AsyncGenerator<SSEEvent> {
  const token = getToken()
  
  const response = await fetch(`${BASE_URL}/api/chat/${threadId}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {})
    },
    body: JSON.stringify({ message, files }),  // 增加 files
    signal
  })
  // ... 后续不变
}
```

---

## 4. Composable 层

**文件**: `src/composables/useChatStream.ts`

```typescript
import { ref } from 'vue'
import { useChatStore } from '@/stores/chat'
import { useSessionStore } from '@/stores/session'
import { streamChat, streamResume } from '@/api/sse'
import { chatApi } from '@/api'
import type { SSEEvent } from '@/types/sse'
import { MAX_FILE_SIZE, MAX_FILE_COUNT } from '@/types/file'

export function useChatStream() {
  const chatStore = useChatStore()
  const sessionStore = useSessionStore()
  const abortController = ref<AbortController | null>(null)

  // 新增：待发送的文件列表
  const pendingFiles = ref<Array<{
    file: File
    path?: string
    status: 'pending' | 'uploading' | 'ready' | 'error'
    error?: string
  }>>([])

  // 新增：添加文件
  function addFiles(files: File[]) {
    const remaining = MAX_FILE_COUNT - pendingFiles.value.length
    const toAdd = files.slice(0, remaining)
    
    for (const file of toAdd) {
      if (file.size > MAX_FILE_SIZE) {
        console.warn(`文件 ${file.name} 超过 50MB，跳过`)
        continue
      }
      pendingFiles.value.push({
        file,
        status: 'pending'
      })
    }
  }

  // 新增：移除文件
  function removeFile(index: number) {
    pendingFiles.value.splice(index, 1)
  }

  // 新增：清空文件
  function clearFiles() {
    pendingFiles.value = []
  }

  // 修改：sendMessage 支持文件
  async function sendMessage(threadId: string, message: string) {
    if (!message.trim() && pendingFiles.value.length === 0) return

    // 1. 上传所有待发送的文件
    const filePaths: string[] = []
    for (const item of pendingFiles.value) {
      if (item.status === 'ready' && item.path) {
        filePaths.push(item.path)
        continue
      }
      
      item.status = 'uploading'
      try {
        const res = await chatApi.uploadSimple(item.file)
        item.path = res.path
        item.status = 'ready'
        filePaths.push(res.path)
      } catch (e) {
        item.status = 'error'
        item.error = e instanceof Error ? e.message : '上传失败'
      }
    }

    // 2. 发送消息
    chatStore.setLoading(true)
    chatStore.setError(null)
    chatStore.addUserMessage(message)
    chatStore.startAssistantMessage()
    sessionStore.incrementMessageCount(threadId)

    // 3. 清空待发送文件
    clearFiles()

    abortController.value = new AbortController()
    try {
      for await (const event of streamChat(threadId, message, filePaths, abortController.value.signal)) {
        handleEvent(event)
      }
    } catch (e: unknown) {
      if (e instanceof Error && e.name === 'AbortError') {
        console.log('Stream aborted')
      } else {
        chatStore.setError(e instanceof Error ? e.message : 'Unknown error')
      }
    } finally {
      chatStore.setLoading(false)
      abortController.value = null
    }
  }

  // ... resumeInterrupt, handleEvent, stopStream 保持不变

  function handleEvent(event: SSEEvent) {
    // ... 现有逻辑不变
  }

  async function resumeInterrupt(threadId: string, action: 'continue' | 'cancel') {
    // ... 现有逻辑不变
  }

  function stopStream() {
    if (abortController.value) {
      abortController.value.abort()
    }
  }

  return {
    sendMessage,
    resumeInterrupt,
    stopStream,
    // 新增导出
    pendingFiles,
    addFiles,
    removeFile,
    clearFiles
  }
}
```

---

## 5. 组件层

**文件**: `src/components/chat/ChatInput.vue`

```vue
<template>
  <div class="chat-input-wrapper">
    <!-- 已选文件列表（输入框上方） -->
    <div v-if="pendingFiles.length > 0" class="pending-files">
      <div 
        v-for="(item, index) in pendingFiles" 
        :key="index" 
        class="file-tag"
        :class="{ 'file-error': item.status === 'error' }"
      >
        <v-icon size="14" class="mr-1">mdi-file-document</v-icon>
        <span class="file-name">{{ item.file.name }}</span>
        <v-progress-circular 
          v-if="item.status === 'uploading'" 
          size="14" 
          width="2" 
          indeterminate 
          class="ml-1"
        />
        <v-icon 
          v-else 
          size="14" 
          class="remove-btn" 
          @click="removeFile(index)"
        >
          mdi-close
        </v-icon>
      </div>
    </div>

    <!-- 输入框 -->
    <div class="chat-input-container">
      <!-- 附件按钮 -->
      <button class="attach-btn" :disabled="disabled" @click="triggerFileInput">
        <v-icon size="20">mdi-paperclip</v-icon>
      </button>
      <input 
        ref="fileInputRef" 
        type="file" 
        multiple 
        hidden 
        @change="handleFileSelect"
      />

      <textarea
        ref="textareaRef"
        v-model="inputText"
        :placeholder="placeholder"
        :disabled="disabled"
        class="chat-textarea"
        rows="1"
        @keydown="handleKeydown"
        @input="autoResize"
      />
      <button
        class="send-btn"
        :disabled="disabled || (!inputText.trim() && pendingFiles.length === 0)"
        @click="handleSend"
      >
        <v-icon size="20">mdi-arrow-up</v-icon>
      </button>
    </div>
    <p class="hint-text">
      按 Enter 发送，Shift + Enter 换行
      <span v-if="pendingFiles.length > 0"> | 已选 {{ pendingFiles.length }}/5 个文件</span>
    </p>
  </div>
</template>

<script setup lang="ts">
import { ref, nextTick } from 'vue'
import { useChatStream } from '@/composables/useChatStream'
import { MAX_FILE_COUNT, MAX_FILE_SIZE } from '@/types/file'

const props = withDefaults(defineProps<{
  disabled?: boolean
  placeholder?: string
}>(), {
  disabled: false,
  placeholder: '给 AI 发送消息'
})

const emit = defineEmits<{
  send: [message: string]
}>()

const { pendingFiles, addFiles, removeFile } = useChatStream()

const inputText = ref('')
const textareaRef = ref<HTMLTextAreaElement | null>(null)
const fileInputRef = ref<HTMLInputElement | null>(null)

function autoResize() {
  nextTick(() => {
    if (textareaRef.value) {
      textareaRef.value.style.height = 'auto'
      textareaRef.value.style.height = Math.min(textareaRef.value.scrollHeight, 200) + 'px'
    }
  })
}

function handleKeydown(e: KeyboardEvent) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault()
    handleSend()
  }
}

function triggerFileInput() {
  fileInputRef.value?.click()
}

function handleFileSelect(e: Event) {
  const target = e.target as HTMLInputElement
  const files = Array.from(target.files || [])
  
  // 过滤超大文件
  const validFiles = files.filter(f => f.size <= MAX_FILE_SIZE)
  if (validFiles.length < files.length) {
    console.warn('部分文件超过 50MB，已跳过')
  }
  
  // 限制数量
  const remaining = MAX_FILE_COUNT - pendingFiles.value.length
  addFiles(validFiles.slice(0, remaining))
  
  // 清空 input
  target.value = ''
}

function handleSend() {
  const message = inputText.value.trim()
  if ((message || pendingFiles.value.length > 0) && !props.disabled) {
    emit('send', message)
    inputText.value = ''
    nextTick(() => {
      if (textareaRef.value) {
        textareaRef.value.style.height = 'auto'
      }
    })
  }
}
</script>

<style scoped>
.chat-input-wrapper {
  padding: 16px 24px 24px;
  background: transparent;
}

/* 已选文件列表 */
.pending-files {
  max-width: 768px;
  margin: 0 auto 8px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.file-tag {
  display: flex;
  align-items: center;
  padding: 4px 8px;
  background-color: rgba(0, 0, 0, 0.06);
  border-radius: 12px;
  font-size: 12px;
  max-width: 200px;
}

.file-tag.file-error {
  background-color: rgba(244, 67, 54, 0.1);
  color: #f44336;
}

.file-name {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.remove-btn {
  cursor: pointer;
  margin-left: 4px;
}

.chat-input-container {
  display: flex;
  align-items: flex-end;
  gap: 8px;
  max-width: 768px;
  margin: 0 auto;
  padding: 12px 16px;
  background-color: rgba(0, 0, 0, 0.04);
  border-radius: 24px;
  transition: background-color 0.2s;
}

.chat-input-container:focus-within {
  background-color: rgba(0, 0, 0, 0.06);
}

/* 附件按钮 */
.attach-btn {
  flex-shrink: 0;
  width: 32px;
  height: 32px;
  border: none;
  background: transparent;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: rgba(0, 0, 0, 0.5);
}

.attach-btn:hover:not(:disabled) {
  color: rgba(0, 0, 0, 0.8);
}

.attach-btn:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.chat-textarea {
  flex: 1;
  border: none;
  outline: none;
  background: transparent;
  font-size: 16px;
  line-height: 1.5;
  resize: none;
  max-height: 200px;
  font-family: inherit;
  color: inherit;
}

.chat-textarea::placeholder {
  color: rgba(0, 0, 0, 0.4);
}

.chat-textarea:disabled {
  opacity: 0.5;
}

.send-btn {
  flex-shrink: 0;
  width: 32px;
  height: 32px;
  border: none;
  border-radius: 50%;
  background-color: #333;
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.send-btn:hover:not(:disabled) {
  background-color: #555;
}

.send-btn:disabled {
  background-color: rgba(0, 0, 0, 0.1);
  cursor: not-allowed;
  color: rgba(0, 0, 0, 0.3);
}

.hint-text {
  text-align: center;
  font-size: 12px;
  color: rgba(0, 0, 0, 0.4);
  margin-top: 8px;
  margin-bottom: 0;
}

/* 暗色主题 */
.v-theme--dark .chat-input-container {
  background-color: rgba(255, 255, 255, 0.06);
}

.v-theme--dark .chat-input-container:focus-within {
  background-color: rgba(255, 255, 255, 0.1);
}

.v-theme--dark .file-tag {
  background-color: rgba(255, 255, 255, 0.1);
}

.v-theme--dark .attach-btn {
  color: rgba(255, 255, 255, 0.5);
}

.v-theme--dark .attach-btn:hover:not(:disabled) {
  color: rgba(255, 255, 255, 0.8);
}

.v-theme--dark .chat-textarea::placeholder {
  color: rgba(255, 255, 255, 0.4);
}

.v-theme--dark .send-btn {
  background-color: #fff;
  color: #333;
}

.v-theme--dark .send-btn:hover:not(:disabled) {
  background-color: #e0e0e0;
}

.v-theme--dark .send-btn:disabled {
  background-color: rgba(255, 255, 255, 0.1);
  color: rgba(255, 255, 255, 0.3);
}

.v-theme--dark .hint-text {
  color: rgba(255, 255, 255, 0.4);
}
</style>
```

---

## 交互流程

```
1. 用户点击附件按钮 → 选择文件
2. 文件展示在输入框上方（标签形式，可删除）
3. 用户输入消息，点击发送
4. 自动上传所有待发送文件 → 获取 path
5. 发送 { message, files: [path1, path2...] }
6. 清空文件列表
```

---

## 限制说明

| 限制 | 值 | 处理 |
|------|-----|------|
| 单文件大小 | ≤ 50MB | 选择时过滤，超限跳过 |
| 单次文件数 | ≤ 5 个 | 限制可选数量 |
| 错误处理 | 上传失败 | 标红显示，不影响其他文件 |
