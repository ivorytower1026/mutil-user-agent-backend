# 测试用例

## 测试环境

- 服务已启动在 `http://localhost:8002`
- 使用 `requests` 库进行 HTTP 测试
- 需要清理测试用户数据

---

## 测试脚本

```python
import requests
import time

BASE_URL = "http://localhost:8002"

def register_user(username: str, password: str) -> dict:
    """注册用户"""
    resp = requests.post(f"{BASE_URL}/api/auth/register", json={
        "username": username,
        "password": password
    })
    return resp.json()

def login_user(username: str, password: str) -> str:
    """登录获取 token"""
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "username": username,
        "password": password
    })
    return resp.json()["access_token"]

def create_thread(token: str) -> str:
    """创建对话"""
    resp = requests.post(f"{BASE_URL}/api/thread", 
        headers={"Authorization": f"Bearer {token}"}
    )
    return resp.json()["thread_id"]

def send_message(token: str, thread_id: str, message: str) -> str:
    """发送消息并返回响应"""
    resp = requests.post(f"{BASE_URL}/api/thread/{thread_id}/chat",
        headers={"Authorization": f"Bearer {token}"},
        json={"message": message},
        stream=True
    )
    result = ""
    for line in resp.iter_lines():
        if line:
            result += line.decode() + "\n"
    return result

def execute_code(token: str, thread_id: str, code: str) -> str:
    """执行代码"""
    return send_message(token, thread_id, f"执行代码：{code}")

def get_container_count() -> int:
    """获取容器数量（需要 docker 命令）"""
    import subprocess
    result = subprocess.run(
        ["docker", "ps", "-q"],
        capture_output=True,
        text=True
    )
    return len(result.stdout.strip().split('\n')) if result.stdout.strip() else 0
```

---

## 测试用例

### 测试1：单用户多对话共享容器

```python
def test_single_user_multiple_threads():
    """验证：同一用户的多个对话共享一个容器"""
    
    # Setup
    username = f"test_user_containers_{int(time.time())}"
    register_user(username, "password123")
    token = login_user(username, "password123")
    
    # 记录初始容器数
    initial_count = get_container_count()
    
    # 创建第一个对话
    thread1 = create_thread(token)
    print(f"[1/4] Created thread1: {thread1}")
    
    # 触发容器创建（执行代码）
    execute_code(token, thread1, "echo 'hello from thread1'")
    time.sleep(2)
    
    count_after_thread1 = get_container_count()
    print(f"[2/4] Containers after thread1: {count_after_thread1}")
    
    # 创建第二个对话
    thread2 = create_thread(token)
    print(f"[3/4] Created thread2: {thread2}")
    
    # 在第二个对话执行代码
    execute_code(token, thread2, "echo 'hello from thread2'")
    time.sleep(2)
    
    count_after_thread2 = get_container_count()
    print(f"[4/4] Containers after thread2: {count_after_thread2}")
    
    # 验证：容器数应该只增加1个（共享）
    assert count_after_thread1 == initial_count + 1, \
        f"Expected {initial_count + 1} containers, got {count_after_thread1}"
    
    assert count_after_thread2 == count_after_thread1, \
        f"Expected same container count, got {count_after_thread2}"
    
    print("✅ Test passed: Single user shares container across threads")
    return True
```

### 测试2：多用户隔离容器

```python
def test_multiple_users_separate_containers():
    """验证：不同用户使用独立容器"""
    
    # Setup 用户A
    username_a = f"test_user_a_{int(time.time())}"
    register_user(username_a, "password123")
    token_a = login_user(username_a, "password123")
    
    # Setup 用户B
    username_b = f"test_user_b_{int(time.time())}"
    register_user(username_b, "password123")
    token_b = login_user(username_b, "password123")
    
    # 记录初始容器数
    initial_count = get_container_count()
    
    # 用户A创建对话并执行代码
    thread_a = create_thread(token_a)
    execute_code(token_a, thread_a, "pip install numpy -q && python -c 'import numpy; print(numpy.__version__)'")
    time.sleep(5)
    
    count_after_a = get_container_count()
    print(f"[1/4] Containers after user A: {count_after_a}")
    
    # 用户B创建对话并执行代码
    thread_b = create_thread(token_b)
    execute_code(token_b, thread_b, "python -c 'import numpy; print(numpy.__version__)'")
    time.sleep(5)
    
    count_after_b = get_container_count()
    print(f"[2/4] Containers after user B: {count_after_b}")
    
    # 验证：容器数应该增加2个（各一个）
    assert count_after_a == initial_count + 1, \
        f"Expected {initial_count + 1} after user A, got {count_after_a}"
    
    assert count_after_b == initial_count + 2, \
        f"Expected {initial_count + 2} after user B, got {count_after_b}"
    
    print("✅ Test passed: Different users have separate containers")
    return True
```

### 测试3：环境共享验证

```python
def test_environment_sharing():
    """验证：同一用户的多个对话共享环境（pip安装）"""
    
    # Setup
    username = f"test_env_share_{int(time.time())}"
    register_user(username, "password123")
    token = login_user(username, "password123")
    
    # 创建对话1，安装一个不常见的包
    thread1 = create_thread(token)
    execute_code(token, thread1, "pip install cowsay -q")
    time.sleep(3)
    
    # 创建对话2，验证包是否可用
    thread2 = create_thread(token)
    result = execute_code(token, thread2, "python -c 'import cowsay; cowsay.cow(\"shared!\")'")
    time.sleep(3)
    
    # 验证：对话2应该能 import 成功
    assert "shared!" in result or "cowsay" in result.lower(), \
        f"Environment not shared between threads"
    
    print("✅ Test passed: Environment shared across threads")
    return True
```

### 测试4：容器销毁

```python
def test_container_destruction():
    """验证：销毁用户容器后，新对话创建新容器"""
    
    # Setup
    username = f"test_destroy_{int(time.time())}"
    register_user(username, "password123")
    token = login_user(username, "password123")
    
    # 创建对话并执行代码
    thread1 = create_thread(token)
    execute_code(token, thread1, "echo 'test'")
    time.sleep(2)
    
    count_before = get_container_count()
    
    # 销毁容器（通过删除对话或调用销毁API）
    # 注：需要实现销毁API，这里假设存在
    # requests.delete(f"{BASE_URL}/api/thread/{thread1}", 
    #     headers={"Authorization": f"Bearer {token}"}
    # )
    
    # 如果没有销毁API，跳过此测试
    print("⚠️ Skipped: No destroy API implemented")
    return True
```

---

## 完整测试脚本

```python
#!/usr/bin/env python
"""v0.1.8 用户级容器共享测试"""

import requests
import time
import subprocess

BASE_URL = "http://localhost:8002"

def wait_for_server(timeout: int = 30):
    """等待服务启动"""
    for _ in range(timeout):
        try:
            requests.get(f"{BASE_URL}/health", timeout=1)
            return True
        except:
            time.sleep(1)
    raise Exception("Server not ready")

def register_user(username: str, password: str) -> dict:
    resp = requests.post(f"{BASE_URL}/api/auth/register", json={
        "username": username,
        "password": password
    })
    return resp.json()

def login_user(username: str, password: str) -> str:
    resp = requests.post(f"{BASE_URL}/api/auth/login", json={
        "username": username,
        "password": password
    })
    return resp.json()["access_token"]

def create_thread(token: str) -> str:
    resp = requests.post(f"{BASE_URL}/api/thread", 
        headers={"Authorization": f"Bearer {token}"}
    )
    return resp.json()["thread_id"]

def send_message(token: str, thread_id: str, message: str) -> str:
    resp = requests.post(f"{BASE_URL}/api/thread/{thread_id}/chat",
        headers={"Authorization": f"Bearer {token}"},
        json={"message": message},
        stream=True
    )
    result = ""
    for line in resp.iter_lines():
        if line:
            result += line.decode() + "\n"
    return result

def get_container_count() -> int:
    result = subprocess.run(
        ["docker", "ps", "-q"],
        capture_output=True,
        text=True
    )
    lines = result.stdout.strip().split('\n')
    return len([l for l in lines if l])

def main():
    print("=== v0.1.8 用户级容器共享测试 ===\n")
    
    wait_for_server()
    print("✓ Server ready\n")
    
    # 测试1
    print("[Test 1] 单用户多对话共享容器...")
    username = f"test1_{int(time.time())}"
    register_user(username, "password123")
    token = login_user(username, "password123")
    
    initial = get_container_count()
    
    t1 = create_thread(token)
    send_message(token, t1, "执行代码：echo hello1")
    time.sleep(3)
    c1 = get_container_count()
    
    t2 = create_thread(token)
    send_message(token, t2, "执行代码：echo hello2")
    time.sleep(3)
    c2 = get_container_count()
    
    assert c1 == initial + 1, f"After thread1: expected {initial+1}, got {c1}"
    assert c2 == c1, f"After thread2: expected {c1}, got {c2}"
    print(f"  ✓ 容器数保持 {c1 - initial} 个\n")
    
    # 测试2
    print("[Test 2] 多用户隔离容器...")
    username_a = f"test2a_{int(time.time())}"
    username_b = f"test2b_{int(time.time())}"
    register_user(username_a, "password123")
    register_user(username_b, "password123")
    token_a = login_user(username_a, "password123")
    token_b = login_user(username_b, "password123")
    
    initial = get_container_count()
    
    ta = create_thread(token_a)
    send_message(token_a, ta, "执行代码：echo userA")
    time.sleep(3)
    ca = get_container_count()
    
    tb = create_thread(token_b)
    send_message(token_b, tb, "执行代码：echo userB")
    time.sleep(3)
    cb = get_container_count()
    
    assert ca == initial + 1, f"After userA: expected {initial+1}, got {ca}"
    assert cb == initial + 2, f"After userB: expected {initial+2}, got {cb}"
    print(f"  ✓ 用户A容器: 1个, 用户B容器: 1个\n")
    
    print("=== 所有测试通过 ===")

if __name__ == "__main__":
    main()
```

---

## 运行测试

```bash
# 确保服务运行
uv run python main.py

# 新终端运行测试
uv run python tests/test_v0_1_8_user_container.py
```

---

## 手动验证

```bash
# 查看当前容器数
docker ps | wc -l

# 查看容器详情
docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Status}}"

# 查看容器挂载
docker inspect <container_id> | grep -A 10 Mounts
```
