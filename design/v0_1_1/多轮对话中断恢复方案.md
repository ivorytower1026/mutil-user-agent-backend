# 多轮对话中断恢复方案（最小实现）

> 版本：v0.1.2  
> 基于版本：v0.1.1 多用户支持版本  
> 规划日期：2026-02-13  
> **核心原则：零改动核心流程，只新增 2 个查询接口**

---

## 一、需求分析

### 用户场景

```
场景1：用户主动中断 SSE 流
┌─────────────────────────────────────────────────────────────────┐
│  1. 用户发送消息，SSE 流开始返回                                 │
│  2. 用户关闭连接（关闭浏览器/取消请求）                          │
│  3. SSE 流自动停止                                              │
│  4. 用户重新发消息，继续对话（保留之前上下文）                   │
└─────────────────────────────────────────────────────────────────┘

场景2：HITL 工具中断（已支持）
┌─────────────────────────────────────────────────────────────────┐
│  1. Agent 执行敏感操作（execute/write_file）                    │
│  2. 触发 interrupt_on 配置，SSE 返回 interrupt 事件             │
│  3. 前端查询 /status 确认中断状态                               │
│  4. 用户选择"继续"或"取消"                                      │
│  5. 调用 /resume 接口恢复执行                                   │
└─────────────────────────────────────────────────────────────────┘
```

---

## 二、现状分析

### 已有能力（无需改动）

| 能力 | 实现方式 | 说明 |
|------|---------|------|
| 用户中断 SSE | 客户端直接关闭连接 | `StreamingResponse` 自动停止迭代器 |
| 状态持久化 | LangGraph `AsyncPostgresSaver` | 每个 checkpoint 自动保存 |
| 继续对话 | LangGraph checkpoint 机制 | 再发消息时自动从 checkpoint 恢复 |
| HITL 中断 | `interrupt_on` 配置 | `/resume` 接口处理 |

### 需要新增

| 接口 | 用途 |
|------|------|
| `GET /status/{thread_id}` | 查询是否处于 HITL 中断状态 |
| `GET /history/{thread_id}` | 获取对话历史消息 |

---

## 三、API 设计

### 1. 状态查询 `GET /api/status/{thread_id}`

**响应：**
```json
{
  "thread_id": "alice-550e8400-xxx",
  "status": "idle",
  "has_pending_tasks": false,
  "interrupt_info": null,
  "message_count": 5
}
```

**status 取值：**
- `idle`：空闲，无待处理任务
- `interrupted`：HITL 中断状态，等待用户确认

### 2. 历史消息 `GET /api/history/{thread_id}`

**响应：**
```json
{
  "thread_id": "alice-550e8400-xxx",
  "messages": [
    {"role": "user", "content": "创建一个 hello.py 文件"},
    {"role": "assistant", "content": "好的，我将为您创建..."}
  ]
}
```

---

## 四、实现方案

### 文件改动清单（约 40 行代码）

| 文件 | 改动 |
|------|------|
| `api/models.py` | +10 行：新增 `ThreadStatus`, `Message`, `HistoryResponse` |
| `src/agent_manager.py` | +20 行：新增 `get_status()`, `get_history()` |
| `api/server.py` | +10 行：新增 2 个路由 |

### 1. api/models.py

```python
from pydantic import BaseModel
from typing import Literal, Optional

class ThreadStatus(BaseModel):
    thread_id: str
    status: Literal["idle", "interrupted"]
    has_pending_tasks: bool
    interrupt_info: Optional[dict] = None
    message_count: int

class Message(BaseModel):
    role: Literal["user", "assistant", "tool", "system"]
    content: str

class HistoryResponse(BaseModel):
    thread_id: str
    messages: list[Message]
```

### 2. src/agent_manager.py

```python
async def get_status(self, thread_id: str) -> dict:
    """获取线程状态"""
    config = {"configurable": {"thread_id": thread_id}}
    snapshot = await self.compiled_agent.aget_state(config)
    
    has_pending_tasks = bool(snapshot.tasks)
    status = "interrupted" if has_pending_tasks else "idle"
    
    interrupt_info = None
    if snapshot.tasks:
        for task in snapshot.tasks:
            if hasattr(task, "interrupts") and task.interrupts:
                interrupt_info = {
                    "task_name": task.name,
                    "interrupts": [str(i) for i in task.interrupts]
                }
                break
    
    messages = snapshot.values.get("messages", [])
    
    return {
        "thread_id": thread_id,
        "status": status,
        "has_pending_tasks": has_pending_tasks,
        "interrupt_info": interrupt_info,
        "message_count": len(messages)
    }

async def get_history(self, thread_id: str) -> dict:
    """获取对话历史"""
    config = {"configurable": {"thread_id": thread_id}}
    snapshot = await self.compiled_agent.aget_state(config)
    messages = snapshot.values.get("messages", [])
    
    formatted_messages = []
    for msg in messages:
        role = "unknown"
        content = ""
        
        if hasattr(msg, "type"):
            msg_type = msg.type
            if msg_type == "human":
                role = "user"
            elif msg_type == "ai":
                role = "assistant"
            elif msg_type == "tool":
                role = "tool"
            elif msg_type == "system":
                role = "system"
        
        if hasattr(msg, "content"):
            content = str(msg.content) if msg.content else ""
        
        if role != "unknown" and content:
            formatted_messages.append({
                "role": role,
                "content": content
            })
    
    return {
        "thread_id": thread_id,
        "messages": formatted_messages
    }
```

### 3. api/server.py

```python
@router.get("/status/{thread_id}", response_model=ThreadStatus)
async def get_thread_status(
    thread_id: str,
    user_id: str = Depends(get_current_user)
):
    """查询线程状态"""
    verify_thread_permission(user_id, thread_id)
    status = await agent_manager.get_status(thread_id)
    return ThreadStatus(**status)


@router.get("/history/{thread_id}", response_model=HistoryResponse)
async def get_thread_history(
    thread_id: str,
    user_id: str = Depends(get_current_user)
):
    """获取对话历史"""
    verify_thread_permission(user_id, thread_id)
    history = await agent_manager.get_history(thread_id)
    return HistoryResponse(**history)
```

---

## 五、用户交互流程

### 中断后继续对话

```
用户发送消息 → SSE 流输出
       ↓
用户关闭连接（中断）
       ↓
Checkpoint 已保存
       ↓
用户发新消息 → POST /chat → 自动恢复上下文
```

### HITL 中断处理

```
Agent 执行敏感操作
       ↓
触发 interrupt_on
       ↓
SSE 返回 {type: "interrupt", info: {...}}
       ↓
前端 GET /status → 确认处于 interrupted 状态
       ↓
显示"继续"/"取消"按钮
       ↓
POST /resume {action: "continue"} → 继续执行
```

---

## 六、验收标准

- [ ] `GET /status/{thread_id}` 正确返回 idle/interrupted 状态
- [ ] `GET /history/{thread_id}` 正确返回对话历史
- [ ] 所有新接口需要 JWT 认证
- [ ] 只能查询自己的 thread（前缀验证）
